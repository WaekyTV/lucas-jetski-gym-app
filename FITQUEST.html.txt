<!DOCTYPE html>
<html><head><meta name="color-scheme" content="light dark"><style id="antigravity-scroll-lock-style">
  html:root body.antigravity-scroll-lock {
    overflow: hidden !important;
  }
</style><style>
  body::-webkit-scrollbar {
    display: none;
  }
  html::-webkit-scrollbar {
    display: none;
  }
</style></head><body class="antigravity-scroll-lock"><pre style="word-wrap: break-word; white-space: pre-wrap;">&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"/&gt;
  &lt;meta content="width=device-width, initial-scale=1.0" name="viewport"/&gt;
  &lt;title&gt;FitQuest&lt;/title&gt;
  &lt;script src="https://cdn.tailwindcss.com"&gt;&lt;/script&gt;
  &lt;link href="https://fonts.googleapis.com/css2?family=VT323&amp;amp;display=swap" rel="stylesheet"/&gt;
  &lt;script src="https://unpkg.com/lucide@latest"&gt;&lt;/script&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"&gt;&lt;/script&gt;
  &lt;style&gt;
   body { font-family: 'VT323', monospace; background-color: #1a202c; color: #e2e8f0; margin: 0; padding: 0; display: flex; flex-direction: column; min-height: 100vh; overflow-x: hidden; }
        .font-vt323 { font-family: 'VT323', monospace; }
        .btn-retro { background-color: #2563eb; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #1e40af; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro:hover { background-color: #1d4ed8; }
        .btn-retro:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-purple { background-color: #9333ea; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #6b21a8; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-purple:hover { background-color: #7e22ce; }
        .btn-retro-purple:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-green { background-color: #16a34a; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #15803d; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-green:hover { background-color: #14713c; }
        .btn-retro-green:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-red { background-color: #dc2626; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #b91c1c; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-red:hover { background-color: #c01b1b; }
        .btn-retro-red:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .card-retro { background-color: #2d3748; padding: 1.5rem; border-radius: 0.5rem; border: 4px solid #a78bfa; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); color: white; }
        .input-retro, .select-retro { box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.1); -webkit-appearance: none; -moz-appearance: none; appearance: none; border: 2px solid #2563eb; border-radius: 0.25rem; width: 100%; padding: 0.5rem 0.75rem; line-height: 1.25; outline: none; transition: all 0.1s ease-in-out; color: #dfdfdf; background-color: #131313; }
        .input-retro:focus, .select-retro:focus { ring: 2px; ring-color: #a78bfa; border-color: #a78bfa; }
        .select-retro option { color: #dfdfdf; background-color: #131313; }
        .table-retro { min-width: 100%; background-color: #4a5568; border-radius: 0.5rem; border: 2px solid #2563eb; }
        .table-retro th { padding: 0.5rem 1rem; text-align: left; font-size: 0.875rem; font-weight: 600; color: #fcd34d; border-bottom: 2px solid #2563eb; }
        .table-retro td { padding: 0.75rem 1rem; font-size: 0.875rem; border-bottom: 1px solid #4a5568; color: #dfdfdf; }
        .table-retro tbody tr:last-child td { border-bottom: 0; }
        .btn-icon { font-size: 1.25rem; padding: 0.25rem; border-radius: 9999px; background-color: transparent; color: white; border: none; cursor: pointer; transition: background-color 0.2s ease-in-out; }
        .btn-icon:hover { background-color: #4a5568; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .xp-bar-container { position: relative; width: 100%; height: 24px; background-color: #333; border: 2px solid #a0a0a0; border-radius: 4px; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .xp-bar-fill { height: 100%; background: linear-gradient(to right, #16a34a, #15803d); transition: width 0.5s ease-in-out, background 0.5s ease-in-out; position: absolute; left: 0; top: 0; border-radius: 2px; animation: xp-glow 1.5s infinite alternate; }
        @keyframes xp-glow { from { box-shadow: 0 0 5px #16a34a; } to { box-shadow: 0 0 15px #15803d; } }
        .xp-bar-text { position: absolute; color: #1a202c; font-size: 0.85rem; font-weight: bold; z-index: 10; text-shadow: 0 0 2px white, 0 0 2px white, 0 0 2px white; }
        .notification-container {
    position: fixed;
    z-index: 1000;
    pointer-events: none;
    /* Supprimer flex-direction pour permettre la superposition via JS */
    /* display: flex; flex-direction: column; gap: 10px; */
}
.notification {
    position: absolute; /* Permet la superposition */
    opacity: 0;
    transition: opacity 0.3s ease-out, transform 0.3s ease-out; /* Transitions plus rapides */
    font-family: 'VT323', monospace;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 250px;
    max-width: 90%;
    padding: 0.5rem 1rem; /* Réduire le padding pour affiner la hauteur */
    border-radius: 0.375rem; /* Rendre les coins légèrement moins arrondis pour un aspect plus fin */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* Ombre plus discrète */
    box-sizing: border-box; /* S'assurer que le padding n'augmente pas la taille totale */
}
.notification-container-bottom-right {
    bottom: 20px;
    right: 20px;
    /* align-items: flex-end; (supprimé car position absolute) */
    width: auto; /* Ajuster la largeur selon le contenu */
    height: auto; /* Ajuster la hauteur selon le contenu */
}
.notification.general, .notification.tip {
    transform: translateX(100%);
    background-color: #2563eb;
    color: white;
    border: 2px solid #1e40af;
    text-align: right;
    border-radius: 0.375rem; /* Ajuster les bords aussi pour la hauteur */
}
/* Styles pour le texte et l'icône dans la notification */
.notification p {
    font-size: 0.875rem; /* Texte légèrement plus petit */
    line-height: 1.2; /* Réduire l'interligne */
}
.notification span {
    font-size: 1.5rem; /* Réduire la taille de l'icône */
}
        .notification.general.error { background-color: #dc2626; border-color: #b91c1c; }
        .notification.general.warning { background-color: #d97706; border-color: #9a3412; }
        .notification.general.success { background-color: #16a34a; border-color: #15803d; }
        .notification.general.chrono { background-color: #9333ea; border-color: #6b21a8; }
        .notification.tip { background-color: #059669; border-color: #065F46; }
        .notification.general.show, .notification.tip.show { transform: translateX(0); opacity: 1; }
        @media (max-width: 640px) {
            .notification-container-bottom-right { left: 50%; transform: translateX(-50%); right: auto; width: 100%; align-items: center; top: auto; bottom: 20px; flex-direction: column-reverse; }
            .notification { width: 90%; margin: 0 auto; border-radius: 0.5rem; text-align: center; flex-direction: column; gap: 0.25rem; }
            .notification.general, .notification.tip { transform: translateX(0) !important; border-radius: 0.5rem; }
            .nav-scroll-container { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; -ms-overflow-style: none; }
            .nav-scroll-container::-webkit-scrollbar { display: none; }
            .nav-items-wrapper { display: flex; flex-wrap: nowrap; padding-bottom: 5px; }
            .nav-item { flex-shrink: 0; min-width: 80px; padding: 0.5rem 0.75rem; margin: 0 0.25rem; }
            .main-content-area { padding-bottom: 6rem; }
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
            transition: background 0.2s ease-in-out;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: #4a5568;
            border-radius: 5px;
            border: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fcd34d;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 2px rgba(0,0,0,.6);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fcd34d;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,.6);
        }
        input[type="range"]::-moz-range-track {
            background: #4a5568;
            border-radius: 5px;
            height: 8px;
        }
        input[type="range"]::-ms-track {
            background: #4a5568;
            border-radius: 5px;
            height: 8px;
            color: transparent;
        }
        input[type="range"]::-ms-thumb {
            width: 20px;
            height: 20px;
            background: #fcd34d;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,.6);
        }
         /* Assure que les clics sur les icônes SVG passent à travers vers le bouton parent */
   .like-meal-btn svg,
   .dislike-meal-btn svg {
       pointer-events: none;
   }
  &lt;/style&gt;
 &lt;/head&gt;
 &lt;body class="font-vt323 text-white bg-gray-900 min-h-screen flex flex-col"&gt;
  &lt;div class="min-h-screen flex flex-col" id="app-container"&gt;
   &lt;header class="bg-gradient-to-r from-blue-700 to-indigo-800 text-yellow-300 p-5 shadow-md border-b-4 border-purple-500 rounded-b-lg"&gt;
    &lt;div class="flex items-center justify-center relative"&gt;
     &lt;button class="absolute left-0 top-1/2 -translate-y-1/2 p-2 rounded-full hover:bg-blue-600 transition-colors duration-200" id="home-button" title="Retour à l'accueil"&gt;
      &lt;i class="text-yellow-300 text-3xl" data-lucide="home"&gt;&lt;/i&gt;
     &lt;/button&gt;
     &lt;h1 class="text-4xl sm:text-5xl lg:text-6xl font-bold text-center tracking-widest leading-tight flex-1"&gt;FITQUEST&lt;/h1&gt;
    &lt;/div&gt;
    &lt;p class="text-center text-lg sm:text-xl mt-2 opacity-90"&gt;TON PROGRAMME PERSONNALISÉ&lt;/p&gt;
    &lt;p class="text-center text-sm sm:text-base mt-1 opacity-80 text-gray-300"&gt;GÉNÉRÉ PAR POXEL, TON IA PERSONNELLE&lt;/p&gt;
    &lt;p class="text-center text-xs sm:text-sm mt-2 opacity-80 text-gray-300 hidden" id="user-id-display"&gt;
     ID UTILISATEUR:
     &lt;span class="font-mono break-all" id="user-id-value"&gt;&lt;/span&gt;
    &lt;/p&gt;
    &lt;div class="flex items-center justify-center my-4 px-4"&gt;
     &lt;i class="text-yellow-400 text-3xl sm:text-4xl mr-2" data-lucide="zap"&gt;&lt;/i&gt;
     &lt;div class="flex-1 xp-bar-container"&gt;
      &lt;div class="xp-bar-fill" id="xp-bar-fill" style="width: 0%;"&gt;&lt;/div&gt;
      &lt;span class="xp-bar-text" id="xp-bar-text"&gt;LVL 0 : 0/100 XP&lt;/span&gt;
     &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="mt-4 p-3 bg-gray-700 rounded-md border-2 border-blue-700"&gt;
     &lt;h3 class="text-lg sm:text-xl font-bold text-yellow-300 mb-2"&gt;TON PROFIL ET STATS VITALES :&lt;/h3&gt;
     &lt;div class="flex flex-col sm:flex-row sm:items-end gap-3 justify-center"&gt;
      &lt;div class="flex-1 w-full sm:w-auto"&gt;
       &lt;label class="block text-gray-200 text-sm font-bold mb-1" for="userHeight"&gt;TAILLE (CM) :&lt;/label&gt;
       &lt;input class="input-retro" id="userHeight" placeholder="EX: 175" type="number"/&gt;
      &lt;/div&gt;
      &lt;div class="flex-1 w-full sm:w-auto"&gt;
       &lt;label class="block text-gray-200 text-sm font-bold mb-1" for="userWeight"&gt;POIDS (KG) :&lt;/label&gt;
       &lt;input class="input-retro" id="userWeight" placeholder="EX: 70" type="number"/&gt;
      &lt;/div&gt;
      &lt;button class="btn-retro-green sm:w-auto w-full px-5 py-2" id="save-profile-btn"&gt;ENREGISTRER&lt;/button&gt;
     &lt;/div&gt;
     &lt;div class="mt-3 text-center text-lg text-white hidden" id="imc-display"&gt;
      &lt;p&gt;TON IMC : &lt;span class="font-bold text-yellow-300" id="imc-value"&gt;&lt;/span&gt;&lt;/p&gt;
      &lt;p&gt;CATÉGORIE : &lt;span class="font-bold text-blue-400" id="imc-category"&gt;&lt;/span&gt;&lt;/p&gt;
      &lt;p&gt;PROTÉINES ESTIMÉES : &lt;span class="font-bold text-yellow-300" id="protein-needs"&gt;&lt;/span&gt;&lt;/p&gt;
      &lt;div class="text-xs text-gray-400 mt-2"&gt;
       &lt;p&gt;**IMC INF. À 16.5 :** INSUFFISANCE PONDÉRALE (DÉNUTRITION SÉVÈRE)&lt;/p&gt;
       &lt;p&gt;**IMC 16.5 À 18.4 :** INSUFFISANCE PONDÉRALE&lt;/p&gt;
       &lt;p&gt;**IMC 18.5 À 24.9 :** POIDS NORMAL&lt;/p&gt;
       &lt;p&gt;**IMC 25 À 26.9 :** SURPOIDS (PRÉ-OBÉSITÉ)&lt;/p&gt;
       &lt;p&gt;**IMC 27 À 29.9 :** OBÉSITÉ MODÉRÉE&lt;/p&gt;
       &lt;p&gt;**IMC 30 À 34.9 :** OBÉSITÉ CLASSE I&lt;/p&gt;
       &lt;p&gt;**IMC 35 À 39.9 :** OBÉSITÉ CLASSE II (SÉVÈRE)&lt;/p&gt;
       &lt;p&gt;**IMC SUP. OU ÉGAL À 40 :** OBÉSITÉ CLASSE III (MORBIDE OU MASSIVE)&lt;/p&gt;
       &lt;p class="mt-2"&gt;**BESOINS EN PROTÉINES :** ESTIMATION POUR LA RÉCUPÉRATION MUSCULAIRE ET LE MAINTIEN DE LA MASSE CORPORELLE, CLÉ POUR TON ACTIVITÉ PHYSIQUE.&lt;/p&gt;
      &lt;/div&gt;
     &lt;/div&gt;
    &lt;/div&gt;
   &lt;/header&gt;
   &lt;nav class="bg-gray-800 shadow-xl py-3 px-2 sm:px-4 border-y-4 border-blue-700 rounded-b-lg mb-4 mx-2"&gt;
    &lt;div class="nav-scroll-container"&gt;
     &lt;div class="nav-items-wrapper"&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="daily_plan"&gt;
       &lt;i class="text-xl" data-lucide="calendar" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;PLANNING&lt;/span&gt;
      &lt;/button&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="workout"&gt;
       &lt;i class="text-xl" data-lucide="dumbbell" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;SPORT&lt;/span&gt;
      &lt;/button&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="recipes"&gt;
       &lt;i class="text-xl" data-lucide="utensils" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;RECETTES&lt;/span&gt;
      &lt;/button&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="chrono"&gt;
       &lt;i class="text-xl" data-lucide="timer" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;CHRONO&lt;/span&gt;
      &lt;/button&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="progress"&gt;
       &lt;i class="text-xl" data-lucide="line-chart" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;ÉVOLUTION&lt;/span&gt;
      &lt;/button&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="trophies"&gt;
       &lt;i class="text-xl" data-lucide="trophy" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;TROPHÉES&lt;/span&gt;
      &lt;/button&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="calendar"&gt;
       &lt;i class="text-xl" data-lucide="calendar-check" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;CALENDRIER&lt;/span&gt;
      &lt;/button&gt;
      &lt;button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="options"&gt;
       &lt;i class="text-xl" data-lucide="settings" style="width:24px; height:24px;"&gt;&lt;/i&gt;
       &lt;span class="text-sm mt-1"&gt;OPTIONS&lt;/span&gt;
      &lt;/button&gt;
     &lt;/div&gt;
    &lt;/div&gt;
   &lt;/nav&gt;
   &lt;main class="flex-1 p-4 sm:p-6 main-content-area max-w-full mx-auto" id="main-content"&gt;&lt;/main&gt;
   &lt;footer class="fixed bottom-0 left-0 right-0 bg-gray-800 shadow-lg p-3 sm:hidden border-t-4 border-blue-700 text-center text-xs text-gray-400"&gt;
    FitQuest - 2023
   &lt;/footer&gt;
  &lt;/div&gt;
  &lt;div id="global-modals-container"&gt;&lt;/div&gt;
  &lt;div class="notification-container notification-container-bottom-right flex-col-reverse" id="notification-container-bottom-right"&gt;&lt;/div&gt;
  &lt;script&gt;
   
function renderLucideIcons() { lucide.createIcons(); }

// Variables d'état globales de l'application
let currentPage = 'daily_plan';
let weeklyMealPlan = null;
let userProfile = { height: '', weight: '', imc: null, imcCategory: '', proteinNeeds: 'N/A', currentXP: 0, earnedTrophies: [], hideExerciseHistory: false, apiKey: '', likedMeals: [], dislikedMeals: [], customNutritionalProgramText: '', customWorkoutProgramJSON: '' };
let workoutLogs = [];
let weightHistory = [];
let intervalSequences = [];
let shifts = [];
let workoutProgram = {};
let previousLevel = 0;
let isAudioActive = true;
let masterVolume = 1;
let trophySoundPlayer, levelUpPlayer, majorLevelUpPlayer, beepPlayer, startSoundPlayer, synth;
let chronoIntervals = [];
let chronoCurrentTime = 0;
let chronoCurrentIntervalIndex = -1;
let isChronoRunning = false;
let isChronoPaused = false;
let enableChronoPreCountdown = true;
let chronoPreCountdownDuration = 10;
let chronoIntervalTimerRef = null;
let weightChartInstance = null;
let exerciseChartInstance = null;
let userId = 'local_user';
let editingIntervalIndex = -1;
let intervalsListDiv = null;
let newDurationSecondsInput = null;
let totalDurationDisplayElement = null;
let newDurationMinutesInput = null;
let newInstructionInput = null;
let addUpdateIntervalBtn = null;
let regeneratingMeal = null; // Flag to control generation state
let numPeople = 1; // Default for meal generation
let allowMeatFish = true; // Default for meal generation
let preferPowderedProtein = false; // Nouvelle variable pour la préférence de protéines en poudre

// Nouvelles variables pour le calendrier d'objectifs
let sportProgramCalendar = {}; // Contiendra les données du calendrier sportif
let totalProgramWeeks = 12; // Durée par défaut du programme en semaines
let currentProgramPhase = 'phase1'; // Phase actuelle du programme
let xpPerWeekCompleted = 50; // XP gagnée par semaine cochée

// Nutritional program text to be passed to the AI
let nutritionalProgramText = `
Programme Nutritionnel Détaillé
Ce document contient ton plan nutritionnel personnalisé, conçu pour s'adapter à tes horaires
spécifiques et à tes besoins, tout en étant économique et favorable à ta santé, notamment avec
la SEP.
Principes Généraux de ta Nutrition
✨

1. Hydratation Optimale
:
○ Bois 3 grands verres d'eau avant chaque repas. C'est excellent pour la satiété et
la digestion.
○ Aie toujours une bouteille d'eau à portée de main, que ce soit au travail ou à la
maison. Bois régulièrement par petites gorgées tout au long de la journée.
○ Les tisanes et le thé non sucrés (en dehors de ta boisson du matin) sont
d'excellentes alternatives.
2. Priorité aux Protéines et aux Fibres
:
○ Les protéines sont essentielles pour la satiété, le maintien de ta masse musculaire
(important pour éviter le relâchement cutané) et sa réparation après l'effort.
Inclus-en à chaque repas principal et dans les collations si besoin.
○ Les fibres, issues des légumes, fruits et glucides complexes, favorisent une bonne
digestion, régulent la glycémie et augmentent la satiété. Mange des légumes à
volonté à chaque repas.
3. Glucides Complexes pour l'Énergie
:
○ Les glucides sont ton carburant. Privilégie les glucides complexes à faible indice
glycémique pour une énergie durable sans pic de sucre (riz, pommes de terre,
patate douce, quinoa, flocons d'avoine, pain complet).
○ Adapte la quantité de glucides à ton niveau d'activité : plus les jours
d'entraînement ou de rondes intenses, un peu moins les jours très sédentaires.
4. Graisses Saines avec Modération
:
○ Les graisses sont importantes pour la santé hormonale et l'absorption des
vitamines. Concentre-toi sur les graisses saines : huiles végétales (olive, colza),
avocats, oléagineux (amandes, noix), poissons gras (saumon, maquereau).
○ Utilise ces graisses avec parcimonie, car elles sont très caloriques.
5. Gestion du Sucre et du Gras ("Plaisirs")
:
○ Monster Energy : Tu peux la conserver comme un plaisir une fois par semaine
(le week-end, ou quand tu dessines/joues). Planifie ce moment pour que cela reste
une récompense et ne devienne pas une habitude.
○ Sucre/Gras occasionnels : Les sorties au bar à jeux ou les "cheat meals" sont
importants pour le moral. Prévois-les et savoure-les sans culpabilité. L'objectif est
de ne pas en faire une routine quotidienne.
6. Aliments pour la Sclérose en Plaques (SEP)
:
○ Bien qu'il n'y ait pas de "régime miracle" pour la SEP, certains aliments peuvent
aider à gérer l'inflammation et soutenir la santé neurologique. Nous privilégierons :
■ Les Oméga-3 : poissons gras (saumon, maquereau, sardines), graines de
lin, graines de chia, noix.
■ Les antioxydants : abondants dans les fruits et légumes colorés (fruits
rouges, légumes verts foncés).
■ La Vitamine D : via l'exposition au soleil (quand possible) et certains
aliments (poissons gras, champignons).
Ton Plan Nutritionnel Détaillé par Type de Jour


1. Jours de Travail : Postes de Jour (6h-18h ou 7h-18h)
☀

● Petit-déjeuner (vers 5h00-6h30, avant de partir)
:
○ Boisson : Une grande tasse de thé ou tisane (aux fruits rouges, verveine, menthe,
etc.) avec une moitié de thé infusé et une moitié de lait demi-écrémé, 2 sucres et 1
cuillère de miel.
○ Option 1 (ta préférée, la "galette" !) : Une galette/pancake à base de 50g de
flocons d'avoine mixés avec 20-30g de whey protéine (goût vanille, chocolat,
neutre...), 1 banane écrasée (ou une poignée de fruits rouges), et un peu d'eau ou
de lait demi-écrémé/végétal pour la consistance. Cuis à la poêle.
○ Option 2 (simple et rapide) :
■ 50g de flocons d'avoine (préparés en porridge avec de l'eau ou du lait
demi-écrémé, sans sucre ajouté)
■ OU 2 tranches de pain complet (environ 60-80g) avec une fine couche de
purée d'oléagineux (amande, cacahuète sans sucre ajouté) ou de miel.
○ Fruit : Un fruit entier à croquer (pomme, poire, orange...).
● Collation matinale (optionnel, si tu as faim ou si le petit-déjeuner est pris très tôt,
vers 9h-10h)
:
○ Un fruit (pomme + 10 amandes) OU une petite poignée d'oléagineux (15-20
amandes ou noix) OU un yaourt grec nature (100-150g).
● Déjeuner (vers 12h-13h)
:
○ Légumes : Une portion généreuse de légumes verts à volonté (brocoli, courgette,
épinards, haricots verts, salade composée avec concombre, tomate, poivron...).
○ Protéines (120-150g cuits, adaptés à ton budget et tes préférences) :
■ Exemples : Filet de poulet grillé, filet de dinde, cabillaud vapeur, thon au
naturel (1 boîte).
■ Alternatives économiques : Lentilles, pois chiches, haricots rouges (environ
150-200g cuits).
■ Option si pas d'autre choix : 1 shaker de whey protéine (30g) mélangé à
de l'eau ou un yaourt grec nature.
○ Féculents (150-200g cuits, à ajuster selon ton activité) : Riz (basmati, complet),
pommes de terre (vapeur, à l'eau), patate douce, quinoa, semoule.
○ Matière grasse : Une cuillère à soupe d'huile d'olive ou de colza pour assaisonner.
● Collation de l'après-midi (vers 17h ou fin de poste, surtout si la journée est longue)
:

○ Un fruit (ex: 1 pomme ou 1 poire) OU un yaourt nature ou fromage blanc (0% ou
20%) OU un shaker de whey protéine OU une petite poignée de noix de cajou ou
amandes (15g).
● Dîner (après le travail, vers 19h)
:
○ Légumes : Une portion généreuse (soupe de légumes, poêlée de légumes,
salade).
○ Protéines (100-120g cuits) : Poisson maigre (cabillaud, sole) OU viande blanche
(poulet, dinde) OU tofu (100-120g) OU 1 shaker de whey protéine (30g).
○ Féculents (100-120g cuits, optionnel si journée très sédentaire) : Quelques
pommes de terre (environ 100g) ou une petite portion de riz (environ 80g).
○ Matière grasse : Une petite cuillère d'huile d'olive ou de colza.
○ Fruit (si faim) : Une pomme ou un autre fruit léger.
2. Jours de Travail : Postes de Nuit (18h-6h)


● Repas AVANT POSTE (vers 17h)
: C'est ton "dîner" principal, il doit t'apporter
suffisamment d'énergie pour la première partie de la nuit.
○ Légumes : Une portion généreuse (salade composée, légumes vapeur, poêlée).
○ Protéines (120-150g cuits, adaptés à ton budget et tes préférences) : Viande
blanche (poulet, dinde) ou poisson (saumon occasionnellement pour les oméga-3,
ou poisson blanc).
○ Féculents (150-200g cuits) : Riz, pommes de terre, patate douce, quinoa.
○ Matière grasse : 1 cuillère à soupe d'huile d'olive ou de colza.
● Collation de début de nuit (vers 22h-23h - facultatif, selon ta faim et tes rondes)
:
Légère pour maintenir ton énergie.
○ Un fruit (banane ou pomme) + 10-15g oléagineux (amandes ou noix).
○ OU 2 tartines de pain complet + purée d'amande.
● Repas PENDANT le poste ("Mini-repas", vers 2h-3h, léger et facile à digérer)
:
○ Légumes : Une portion de légumes (crudités faciles à manger, reste de légumes
cuits du dîner, ou une soupe de légumes).
○ Protéines (80-100g cuits) : Poisson blanc (cabillaud, colin) ou thon au naturel
(petite boîte) OU un œuf dur (si ok) OU du fromage blanc/yaourt grec.
○ Alternative protéine en poudre : Un petit shaker de whey protéine (20-25g) avec
de l'eau, si tu préfères une option très légère et rapide.
○ Féculents (80-100g cuits) : Une très petite portion de riz, pommes de terre ou
patate douce, ou une tranche de pain complet. À ajuster en fonction de tes rondes :
si tu as fait une ronde intense, une petite portion peut être utile.
○ Matière grasse : Un filet d'huile pour assaisonner.
● Collation de fin de nuit (vers 4h-5h - facultatif, si tu as fait une seconde ronde et
sens un coup de barre)
:
○ Un fruit OU un yaourt nature OU une petite poignée de noix.
● Repas APRÈS POSTE (vers 6h30-7h, avant de dormir)
: Ce repas est important
pour la récupération et la satiété avant le sommeil.
○ Boisson : Ton thé/tisane préféré (thé aux fruits rouges, lait demi-écrémé, 2 sucres,
1 cuillère de miel).
○ Source de glucides complexes et protéines :
■ Galette/Pancake protéiné : 50g de flocons d'avoine, 20-30g de whey
protéine, 1 banane écrasée (ou fruits rouges), un peu d'eau/lait. Cuit à la
poêle.
■ Option simple : 50g de flocons d'avoine en porridge (eau/lait), ou 2 tranches
de pain complet avec purée d'oléagineux/miel.
○ Fruit : Un fruit entier à croquer (kiwi, pomme).
3. Jours de Repos / Créatifs / Chill


● Petit-déjeuner ou Brunch (selon ton réveil, entre 8h et 10h)
☀
:
○ Boisson : Une grande tasse de thé ou tisane (avec lait demi-écrémé, 2 sucres et 1
cuillère de miel).
○ Option 1 (galette/pancake) : Galette à base de 50g de flocons d'avoine mixés
avec 20-30g de whey protéine, 1 banane écrasée (ou fruits rouges), et un peu
d'eau ou de lait demi-crémé/végétal.
○ Option 2 (variété !) :
■ 50g de flocons d'avoine en porridge (avec fruits rouges + yaourt nature + 1
cuillère de miel).
■ OU 2-3 tranches de pain complet toastées avec purée d'oléagineux/miel +
1 banane en tranches.
■ OU Bowl protéiné : quinoa + fromage blanc + fruits secs (raisins, abricots).
● Collation matinale (si besoin, entre 10h30 et 11h30)
:
○ Un fruit (pomme ou poire) OU petite poignée d'oléagineux (15-20 amandes ou noix)
OU yaourt grec nature (100-150g).
● Déjeuner (vers 13h)
:
○ Légumes : Une portion généreuse de légumes variés.
○ Protéines (120-150g cuits, varie tes sources !) :
■ Viande blanche (poulet, dinde) ou poisson maigre (cabillaud, colin).
■ Poissons gras : 1 à 2 fois par semaine, du saumon, maquereau ou sardines
pour les précieux Oméga-3.
■ Alternatives : Légumineuses (lentilles, pois chiches, haricots rouges -
environ 150-200g cuits), tofu.
○ Féculents (150-200g cuits, à ajuster) : Riz, pommes de terre, patate douce,
quinoa, semoule.
○ Matière grasse : Une cuillère à soupe d'huile d'olive ou de colza.
● Collation de l'après-midi (si besoin, vers 16h-17h)
:
○ Un fruit OU un yaourt nature ou fromage blanc (0% ou 20%) OU un shaker de
whey protéine avec de l'eau OU une petite poignée de noix de cajou ou amandes
(15g).
○ Option "plaisir maison" : 1 part de gâteau flocons d'avoine/whey maison (type
banana bread protéiné).
● Dîner (vers 19h-20h)
:
○ Légumes : Une portion généreuse (soupe, poêlée, légumes vapeur).
○ Protéines (100-120g cuits) : Poisson maigre (cabillaud, sole) OU viande blanche
(poulet, dinde) OU tofu OU whey protéine.
○ Féculents (100-150g cuits, optionnel si journée très sédentaire) : Une portion
modérée de riz, pommes de terre ou patate douce. Si c'est un jour de repos sans
sport, tu peux réduire légèrement.
○ Matière grasse : Une petite cuillère d'huile d'olive ou de colza.
○ Fruit (si faim) : Une pomme ou un autre fruit léger.

Notes générales pour ta Nutrition :
● Varie les plaisirs ! Change les fruits et légumes selon la saison.
● Cuissons douces : Privilégie la vapeur, le four, les sautés rapides.
● Assaisonnement : Limite les sauces industrielles. Préfère huile d'olive, jus de citron,
vinaigre, herbes fraîches et épices.
● Hydratation : Bois beaucoup d'eau, thé et tisanes tout au long de la journée.
● Préparation (Batch Cooking)
: Profite de tes jours de repos pour préparer certains
repas ou ingrédients à l'avance (ex: cuire une grande quantité de riz, couper des
légumes, préparer des portions de protéines). Cela te fera gagner un temps précieux en
semaine !
`;
const basicFitRecipes = {
    "PETIT-DÉJEUNER": [
        "Pain perdu avec avocat et œuf au plat (15 min)",
        "Beignets de courgettes et de carottes sauce avocat (40 min)",
        "Porridge au chocolat protéiné (10 min)",
        "Huevos Rancheros (15 min)",
        "Pancakes protéinés à la banane (15 min)",
        "Smoothie Bowl au chocolat chaud (10 min)",
        "Bol de smoothie au chocolat chaud (10 min)",
        "Tomates balsamiques rôties &amp; Toast au houmous (25 min)",
        "Mugcake à la vanille (6 min)",
        "Mug Cake protéiné à la vanille (3 min)",
        "Yaourt, mangue et granola (10 min)",
        "Trifle à la framboise (10 min)",
        "Pancakes protéinés à l'orange et au yaourt (15 min)",
        "Crêpes aux myrtilles riches en protéines (15 min)",
        "Bol de protéines du smoothie d'été (10 min)",
        "Yaourt à la vanille et à l'avoine (5 min)",
        "Banana &amp; Coconut Bread (55 min)",
        "Œufs brouillés au curry (15 min)",
        "Crêpes aux baies (20 min)",
        "Pancakes protéinés au fromage blanc (20 min)",
        "Muffins végétaliens (45 min)",
        "Crème de millet coco-banane (20 min)",
        "Fromage blanc (quark) à la grenade, à la noix de coco &amp; au chocolat noir (5 min)",
        "Des beignets de maïs sucré rapides (20 min)",
        "Crêpes de sarrasin sans œufs (40 min)",
        "Pudding aux graines de chia (5 min)",
        "Pudding au chocolat et au millet (20 min)",
        "Œufs brouillés à l'asiatique (15 min)",
        "Tacos protéinés aux fruits (10 min)",
        "Bol de smoothie à la framboise (10 min)",
        "Pudding de chia protéiné à la fraise (15 min)",
        "Crumble de pommes pour le petit déjeuner (35 min)",
        "Gâteau à la banane et à la fraise pauvre en glucides (70 min)",
        "Pancakes vegan à la banane (30 min)",
        "Toast au fromage de chèvre et avocat (5 min)",
        "Pancakes de patate douce sains (30 min)",
        "Toast à l'avocat, feta et grenade (5 min)",
        "Omelette aux épinards, avocat et cottage cheese (15 min)",
        "Petit-déjeuner équilibré et nutritif avec œuf au plat (20 min)",
        "Salade de quinoa au petit-déjeuner avec œuf au plat (20 min)",
        "Smoothie Bowl (10 min)",
        "Avocat, tapenade et toast aux œufs (10 min)",
        "Porridge pomme cannelle (20 min)",
        "Pancakes aux amandes et à la banane (25 min)",
        "Smoothie Bowl à l'orange (10 min)",
        "Flocons d'avoine au chocolat noir et coco (15 min)",
        "Avocat et tomates au basilic sur toast (10 min)",
        "Chia Pudding au chocolat et à la noix de coco (15 min)",
        "Pudding au chocolat et au chia (10 min)",
        "Œufs au plat aux tomates et thon (10 min)",
        "Pancake de courgettes et feta (15 min)",
        "Purée d'avocat aux œufs (10 min)",
        "Pain perdu (20 min)",
        "Muffins aux œufs, brocoli et jambon (20 min)"
    ],
    "DÉJEUNER": [
        "Curry de poulet simple avec du riz safrané (60 min)",
        "Taboulé de quinoa et courgette au poulet Harissa (35 min)",
        "Pommes de terre &amp; choux de Bruxelles avec saucisse (40 min)",
        "Pancakes aux pois chiches, bœuf et lentilles (35 min)",
        "Salade de quinoa arc-en-ciel avec dinde grillée (20 min)",
        "Beignets de courgettes et de carottes sauce avocat (40 min)",
        "Saumon cuit au four avec des zoodles et du quinoa (25 min)",
        "Pâtes aux tomates, haricots verts et morue (30 min)",
        "Soupe aux champignons (45 min)",
        "Pâtes potiron à la bolognaise (45 min)",
        "Saumon fumé et salade de fraises (5 min)",
        "Zoodles au quinoa &amp; œuf poché (25 min)",
        "Sauté de crevettes au curry facile (20 min)",
        "Tofu épicé à la sauce à l'ail (50 min)",
        "Salade de thon et de quinoa (20 min)",
        "Wraps de Sharma à la betterave vegan (30 min)",
        "Omelette au saumon fumé, feta et asperges (25 min)",
        "Pain perdu (20 min)",
        "Wraps à la salade de thon (10 min)",
        "Ragoût d'épinards végétaliens (25 min)",
        "Salade d'avocats et de thon en couches (10 min)",
        "Soupe d'aneth avec boulettes de viande de dinde (45 min)",
        "Beef Keema (45 min)",
        "Morue avec des zoodles crémeux (30 min)",
        "Omelette au fromage blanc et basilic (20 min)",
        "Pancakes de patate douce (25 min)",
        "Curry de pommes de terre crémeuses à la noix de coco (40 min)",
        "Salade de chou frisé et tofu avec vinaigrette au beurre d'arachide (20 min)",
        "Salade de tahini superfood (10 min)",
        "Goulasch d'aubergine fumé (60 min)",
        "Frites de courgette (35 min)",
        "Tajine d'aubergine (40 min)",
        "Lasagnes végétariennes (60 min)",
        "Salade de poulet pesto et brocoli (25 min)",
        "Smoothie Bowl à l'orange (10 min)",
        "Shakshuka vert (40 min)",
        "Patates douces rôties avec houmous et pesto (45 min)",
        "Poivrons farcis à l'œuf et à la dinde (25 min)",
        "Salade de concombres écrasés au saumon (10 min)",
        "Riz frit aux œufs et à la dinde (20 min)",
        "Salade de poulet, d'orange et de noix (20 min)",
        "Pâtes crémeuses végétaliennes aux tomates séchées (15 min)",
        "Salade de poulet thaïlandaise (15 min)",
        "Pâtes au thon et aux épinards (15 min)",
        "Salade de thon et de pommes de terre avec vinaigrette à l'orange (40 min)",
        "Salade asiatique au poulet (25 min)",
        "Salade de saumon et de pêches (45 min)",
        "Salade de fromage de chèvre, poires et noix (10 min)",
        "Curry de légumes rapide (25 min)",
        "Spaghettis sans viande (25 min)",
        "Curry végétalien de patate douce et de chou-fleur (45 min)",
        "Pois chiches et aubergine farcie au tahini (45 min)",
        "Salade de citrouille grillée, tofu et boulgour (30 min)",
        "Crêpes farcies aux épinards, à la tomate et à la feta (35 min)",
        "Salade de poulet Waldorf (10 min)",
        "Salade grecque de zoodle (10 min)",
        "Salade de quinoa végétalienne (20 min)",
        "Risotto style Chakalaka (40 min)",
        "Soupe au poulet (35 min)",
        "Salade de poulet au citron grillé (40 min)",
        "Wraps coréens au poulet (70 min)",
        "Mijoté de chou-fleur Tikka Masala (10 min)",
        "Salade de chou frisé, quinoa et canneberges (25 min)",
        "Saumon, pommes de terre &amp; asperges au four (40 min)",
        "Ragoût de poisson et de citrouille (20 min)",
        "Sauté de poulet à l'orange (35 min)",
        "Pâtes crémeuses au poulet, aux champignons et aux tomates (30 min)",
        "Quinoa mexicain (30 min)",
        "Sauté de bœuf et de brocoli (25 min)",
        "Curry de pois chiches, patate douce et épinards (30 min)",
        "Des chips simples au chili et à la patate douce (50 min)",
        "Hachis de patates douces et de courgettes (20 min)",
        "Nouilles crémeuses aux crevettes (20 min)",
        "Soupe crémeuse au potiron (30 min)",
        "Tombet espagnol (70 min)",
        "Marmite de dinde épicée et son riz (35 min)",
        "Salade de légumes racines rôtis à la feta (40 min)",
        "Ragoût de lentilles espagnol (55 min)",
        "Salade de chou frisé et de brocoli (25 min)",
        "Saumon glacé au miel et au citron vert avec son riz à l'ananas (100 min)",
        "Curry poulet, pomme de terre (30 min)",
        "Omelette aux épinards, avocat et cottage cheese (15 min)",
        "Wraps mexicains au poulet grillé et avocat (20 min)",
        "Pancakes vegan à la banane (30 min)",
        "Toast au fromage de chèvre et avocat (5 min)",
        "Salade verte avec vinaigrette (10 min)",
        "Fondue de thon végétalienne (10 min)",
        "Soupe d'asperges au curry (60 min)",
        "Bœuf au sésame et au gingembre avec des nouilles de courgettes (17 min)",
        "Risotto crémeux aux poireaux (35 min)",
        "Salade de poires, jambon et noix (15 min)",
        "Soupe de potiron de la pleine lune (40 min)",
        "Rouleaux de printemps de saumon (15 min)",
        "Soupe Tom Yum aux crevettes (15 min)",
        "Houmous aux haricots noirs (5 min)",
        "Pico de Gallo (10 min)",
        "Salade de lentilles (45 min)",
        "Salade d'asperges (15 min)",
        "Salade de nouilles de patates douces (20 min)",
        "Salade d'œufs au curry (15 min)",
        "Salade de dinde et de brocoli (20 min)",
        "Salade de haricots noirs au poulet et à l'avocat (20 min)",
        "Salade de lentilles et d'halloumi (25 min)",
        "Soupe de légumes au curry (35 min)",
        "Poulet de cajou simple (20 min)",
        "Salade de quinoa, brocoli et poulet (20 min)",
        "Salade de chou-fleur (25 min)",
        "Salade de poulet de type thaï (15 min)",
        "Poulet du Général Tso (35 min)"
    ],
    "COLLATION": [
        "Houmous classique (10 min)",
        "Bouchées de chocolat à la banane (90 min)",
        "Écorce de chocolat superfood (35 min)",
        "Ferrero Rocher, version plus saine (10 min)",
        "Houmous aux haricots noirs (5 min)",
        "Des beignets de maïs sucré rapides (20 min)",
        "Latte de curcuma doré (10 min)",
        "Pico de Gallo (10 min)",
        "Des biscuits simples à l'avoine (30 min)",
        "Smoothie protéiné façon Pina Colada (5 min)",
        "Pancakes de patate douce (25 min)",
        "Tarte au potiron (30 min)",
        "Muffins sans farine à la banane et aux noix de cajou (20 min)",
        "Brownies au beurre de cacahuète sans farine (40 min)",
        "Crème de bananes glacés protéinée (5 min)",
        "Biscuits faciles à base d'avoine et de carottes (30 min)",
        "Trifle à la framboise (10 min)",
        "Crêpes aux myrtilles riches en protéines (15 min)",
        "Gâteau crémeux aux poires (65 min)",
        "Yaourt à la vanille et à l'avoine (5 min)",
        "Tropical Smoothie (5 min)",
        "Pudding aux graines de chia (5 min)",
        "Pudding au chocolat et au millet (20 min)",
        "Gâteau végétalien au citron et à la noix de coco (75 min)",
        "Pudding aux protéines de millet et framboise (20 min)",
        "Energy Balls aux amandes (10 min)",
        "Frites de courgette (35 min)",
        "Biscuits chocolatés à l'avoine (45 min)",
        "Smoothie protéiné à la cannelle (5 min)",
        "Smoothie protéiné aux fruits rouges (5 min)",
        "Muffins végétaliens (45 min)",
        "Smoothie vert (5 min)",
        "Pudding au chia et aux bananes (15 min)",
        "Mousse au chocolat et à l'orange (30 min)",
        "Bouchées de courgettes croustillantes (25 min)",
        "Smoothie vert enrichi en protéines (5 min)",
        "Flocons d'avoine au chocolat noir et coco (15 min)",
        "Patates douces rôties avec houmous et pesto (45 min)",
        "Avocat et tomates au basilic sur toast (10 min)",
        "Smoothie protéiné à la framboise (5 min)",
        "Pudding de chia protéiné à la fraise (15 min)",
        "Crumble de pommes pour le petit déjeuner (35 min)",
        "Gâteau à la banane et à la fraise pauvre en glucides (70 min)",
        "Mocha Truffles (130 min)",
        "Pois chiches à l'ail grillés (50 min)",
        "Pancakes vegan à la banane (30 min)",
        "Truffes à la vanille et à la noix de coco (70 min)",
        "Biscuits protéinés aux noisettes (20 min)",
        "Crispy Tofu (45 min)",
        "Crème de millet coco-banane (20 min)",
        "Smoothie vert énergisant (5 min)",
        "Énergie Ball noix de coco &amp; beurre de cacahuète (10 min)",
        "Fromage blanc (quark) à la grenade, à la noix de coco &amp; au chocolat noir (5 min)",
        "Pancakes à la banane post-entraînement (20 min)",
        "Muffins aux œufs, brocoli et jambon (20 min)",
        "Houmous classique (10 min)",
        "Biscuits protéinés aux noisettes (20 min)",
        "Toast à l'avocat, feta et grenade (5 min)",
        "Muffins protéinés à la fraise (35 min)",
        "Beignets aux pommes et à la cannelle (15 min)",
        "Smoothie mangue &amp; curcuma (5 min)",
        "Smoothie Bowl au chocolat chaud (10 min)",
        "Tomates balsamiques rôties &amp; Toast au houmous (25 min)",
        "Smoothie banane/orange post entraînement (5 min)",
        "Chia Pudding au chocolat et à la noix de coco (15 min)",
        "Pudding au chocolat et au chia (10 min)",
        "Mugcake à la vanille (6 min)",
        "Mug Cake protéiné à la vanille (3 min)",
        "Dessert hyperprotéiné au chocolat et aux noisettes (10 min)",
        "Pain au chocolat, aux amandes et aux courgettes (65 min)"
    ],
    "DÎNER": [
        "Sauté de bœuf et de brocoli (25 min)",
        "Soupe crémeuse au potiron (30 min)",
        "Pâtes potiron à la bolognaise (45 min)",
        "Filet de poulet aux herbes et pommes de terre au four (45 min)",
        "Sauté de crevettes au curry facile (20 min)",
        "Tofu épicé à la sauce à l'ail (50 min)",
        "Wraps de Sharma à la betterave vegan (30 min)",
        "Fondue de thon végétalienne (10 min)",
        "Soupe d'asperges au curry (60 min)",
        "Bœuf au sésame et au gingembre avec des nouilles de courgettes (17 min)",
        "Risotto crémeux aux poireaux (35 min)",
        "Marmite de dinde épicée et son riz (35 min)",
        "Ragoût de lentilles espagnol (55 min)",
        "Rigatoni alla Norma (20 min)",
        "Pide turc à la merguez de bœuf (75 min)",
        "Fajitas au bœuf haché, avocat et salsa de tomates (28 min)",
        "Sushibowl avec saumon fumé et mayonnaise au gingembre (25 min)",
        "Cuisse de poulet confite croustillante laquée au Ketjap (50 min)",
        "Orzo garni de ricotta au citron (60 min)",
        "Saumon glacé au miel et au citron vert avec son riz à l'ananas (100 min)",
        "Nouilles et émincé de bœuf en sauce asiatique (50 min)",
        "Salade de boulgour aux légumes rôtis et fromage de chèvre (45 min)",
        "Curry poulet, pomme de terre (30 min)",
        "Sauté de brocoli et de poulet (25 min)",
        "Curry de poulet simple avec du riz safrané (60 min)",
        "Pommes de terre &amp; choux de Bruxelles avec saucisse (40 min)",
        "Pancakes aux pois chiches, bœuf et lentilles (35 min)",
        "Bœuf cajun et riz aux légumes (35 min)",
        "Salade de quinoa arc-en-ciel avec dinde grillée (20 min)",
        "Pilons de poulet marocains (60 min)",
        "Saumon cuit au four avec des zoodles et du quinoa (25 min)",
        "Pâtes aux tomates, haricots verts et morue (30 min)",
        "Salade de poulet, d'orange et de noix (20 min)",
        "Pâtes crémeuses végétaliennes aux tomates séchées (15 min)",
        "Salade de poulet thaïlandaise (15 min)",
        "Crevettes et légumes à la chinoise (30 min)",
        "Pâtes au thon et aux épinards (15 min)",
        "Salade asiatique au poulet (25 min)",
        "Saumon, pommes de terre &amp; asperges au four (40 min)",
        "Ragoût de poisson et de citrouille (20 min)",
        "Sauté de poulet à l'orange (35 min)",
        "Pâtes crémeuses au poulet, aux champignons et aux tomates (30 min)",
        "Quinoa mexicain (30 min)",
        "Curry de légumes rapide (25 min)",
        "Spaghettis sans viande (25 min)",
        "Curry végétalien de patate douce et de chou-fleur (45 min)",
        "Pois chiches et aubergine farcie au tahini (45 min)",
        "Salade de citrouille grillée, tofu et boulgour (30 min)",
        "Salade de poulet Waldorf (10 min)",
        "Lasagnes végétariennes (60 min)",
        "Salade de poulet pesto et brocoli (25 min)",
        "Cuisses de poulet au riz Hoisin (55 min)",
        "Riz à la noix de coco et aux crevettes (50 min)",
        "Bœuf rapide Chow Mein (20 min)",
        "Salade de concombres écrasés au saumon (10 min)",
        "Curry indien de pois chiches et de citrouille (45 min)",
        "Riz frit aux œufs et à la dinde (20 min)",
        "Nouilles asiatiques au poulet et aux légumes (25 min)",
        "Sauté de poulet et de mangue (20 min)",
        "Sauté de porc chinois à l'ananas (30 min)",
        "Bœuf et lentilles bolognaise (50 min)",
        "Omelette au saumon fumé, feta et asperges (25 min)",
        "Salade d'avocats et de thon en couches (10 min)",
        "Soupe d'aneth avec boulettes de viande de dinde (45 min)",
        "Beef Keema (45 min)",
        "Soupe au poulet (35 min)",
        "Mijoté de chou-fleur Tikka Masala (10 min)",
        "Salade de chou frisé, quinoa et canneberges (25 min)",
        "Curry de pommes de terre crémeuses à la noix de coco (40 min)",
        "Soupe mexicaine au poulet (25 min)",
        "Frites de courgette (35 min)",
        "Tajine d'aubergine (40 min)",
        "Soupe de potiron de la pleine lune (40 min)",
        "Soupe de légumes au curry (35 min)",
        "Bouillon de poulet pour renforcer le système immunitaire (180 min)",
        "Soupe Tom Yum aux crevettes (15 min)"
    ]
};
// Liste de tous les trophées disponibles et leurs conditions
const allTrophies = [
    { id: 't001', name: 'PREMIER PAS', description: 'Atteindre le Niveau 1. Le voyage commence !', levelRequired: 1 },
    { id: 't002', name: 'NOVICE EN FORME', description: 'Atteindre le Niveau 2. Vous prenez le rythme.', levelRequired: 2 },
    { id: 't003', name: 'INITIÉ DU FIT', description: 'Atteindre le Niveau 3. Les efforts paient.', levelRequired: 3 },
    { id: 't004', name: 'FORME CROISSANTE', description: 'De mieux en mieux !', levelRequired: 4 },
    { id: 't005', name: 'DÉBUTANT AVANCÉ', description: 'Vous n\'êtes plus un débutant.', levelRequired: 5 },
    { id: 't006', name: 'CONSTANCE MÉRITÉE', description: 'La régularité, c\'est la clé.', levelRequired: 6 },
    { id: 't007', name: 'ÉLAN DU PROGRÈS', description: 'Vous sentez la progression.', levelRequired: 7 },
    { id: 't008', name: 'GAINS ASSURÉS', description: 'Les efforts paient.', levelRequired: 8 },
    { id: 't009', name: 'AVANCÉE RAPIDE', description: 'Vous brûlez les étapes.', levelRequired: 9 },
    { id: 't010', name: 'DIXIÈME ÉTAPE', description: 'Un jalon important !', levelRequired: 10 },
    { id: 't011', name: 'MAÎTRE INTERMÉDIAIRE', description: 'Le fitness devient une habitude.', levelRequired: 11 },
    { id: 't012', name: 'FORCE ÉMERGENTE', description: 'Vos limites sont repoussées.', levelRequired: 12 },
    { id: 't013', name: 'ENDURANCE ACCRUE', description: 'Le cardio n\'a plus de secret.', levelRequired: 13 },
    { id: 't014', name: 'EXCELLENCE EN VUE', description: 'La performance est à portée.', levelRequired: 14 },
    { id: 't015', name: 'DEMI-MAÎTRE', description: 'Vous êtes sur la bonne voie.', levelRequired: 15 },
    { id: 't016', name: 'DISCIPLINE DE FER', description: 'Votre engagement est fort.', levelRequired: 16 },
    { id: 't017', name: 'ÉNERGIE DÉCUPLÉE', description: 'Sentez cette vitalité !', levelRequired: 17 },
    { id: 't018', name: 'HARMONIE CORPS/ESPRIT', description: 'L\'équilibre est parfait.', levelRequired: 18 },
    { id: 't019', name: 'FORME OPTIMALE', description: 'Vous rayonnez de santé.', levelRequired: 19 },
    { id: 't020', name: 'DEUXIÈME DIZAINE', description: 'Double décennie de fitness !', levelRequired: 20 },
    { id: 't021', name: 'EXPERT EN DEVENIR', description: 'La maîtrise approche.', levelRequired: 21 },
    { id: 't022', name: 'PUISSANCE RÉVÉLÉE', description: 'Une force insoupçonnée.', levelRequired: 22 },
    { id: 't023', name: 'AGILITÉ MAXIMALE', description: 'Votre corps est un temple agile.', levelRequired: 23 },
    { id: 't024', name: 'RÉSISTANCE INÉGALÉE', description: 'Rien ne vous arrête.', levelRequired: 24 },
    { id: 't025', name: 'QUART DE SIÈCLE', description: 'Vous êtes une machine !', levelRequired: 25 },
    { id: 't026', name: 'PERFECTION EN MARCHE', description: 'Chaque pas est un succès.', levelRequired: 26 },
    { id: 't027', name: 'FORME INCROYABLE', description: 'Admirez votre progression !', levelRequired: 27 },
    { id: 't028', name: 'DÉTERMINATION ACÉRÉE', description: 'Votre volonté est sans faille.', levelRequired: 28 },
    { id: 't029', name: 'INÉPUISABLE', description: 'L\'énergie vous habite.', levelRequired: 29 },
    { id: 't030', name: 'LE TREINTIÈME', description: 'Un cap monumental !', levelRequired: 30 },
    { id: 't031', name: 'MAÎTRE ABSOLU', description: 'Vous êtes une référence.', levelRequired: 31 },
    { id: 't032', name: 'EXPERT LÉGENDAIRE', description: 'Votre réputation vous précède.', levelRequired: 32 },
    { id: 't033', name: 'OLYMPIEN EN HERBE', description: 'Digne des plus grands athlètes.', levelRequired: 33 },
    { id: 't034', name: 'CHAMPION INCROYABLE', description: 'Votre esprit est indomptable.', levelRequired: 34 },
    { id: 't035', name: 'LE PRODIGE', description: 'Vos prouesses sont inégalées.', levelRequired: 35 },
    { id: 't036', name: 'FORCE DE LA NATURE', description: 'Vous êtes imparable.', levelRequired: 36 },
    { id: 't037', name: 'FORME DIVINE', description: 'Votre corps est une œuvre d\'art.', levelRequired: 37 },
    { id: 't038', name: 'CONNAISSANCE SUPRÊME', description: 'Votre savoir est immense.', levelRequired: 38 },
    { id: 't039', name: 'RÉALISATION PARFAITE', description: 'Tout est sous contrôle.', levelRequired: 39 },
    { id: 't040', name: 'QUARANTIÈME HORIZON', description: 'Le ciel est votre limite !', levelRequired: 40 },
    { id: 't041', name: 'LÉGENDE VIVANTE', description: 'On parlera de vous.', levelRequired: 41 },
    { id: 't042', name: 'INSPIRATION ULTIME', description: 'Vous inspirez les foules.', levelRequired: 42 },
    { id: 't043', name: 'DÉFI RELEVÉ', description: 'Chaque obstacle est un tremplin.', levelRequired: 43 },
    { id: 't044', name: 'SUMMUM DE LA FORME', description: 'Vous êtes au sommet.', levelRequired: 44 },
    { id: 't045', name: 'LE MAÎTRE CULMINANT', description: 'La perfection incarnée.', levelRequired: 45 },
    { id: 't046', name: 'IMPARABLE', description: 'Vous êtes invaincu !', levelRequired: 46 },
    { id: 't047', name: 'VOLONTÉ DE DIAMANT', description: 'Votre détermination est inébranlable.', levelRequired: 47 },
    { id: 't048', name: 'ÉCLAT ÉTERNEL', description: 'Votre aura brille.', levelRequired: 48 },
    { id: 't049', name: 'CONNAISSANCE ABSOLUE', description: 'Le savoir vous guide.', levelRequired: 49 },
    { id: 't050', name: 'LE CINQUANTIÈME', description: 'Une performance extraordinaire !', levelRequired: 50 },
    { id: 't051', name: 'GRAND MAÎTRE', description: 'Vous êtes au-delà de l\'excellence.', levelRequired: 51 },
    { id: 't052', name: 'ARCHITECTE DU CORPS', description: 'Vous sculptez votre destin.', levelRequired: 52 },
    { id: 't053', name: 'ARTISAN DE LA SANTÉ', description: 'Votre bien-être est une œuvre.', levelRequired: 53 },
    { id: 't054', name: 'GUERRIER DE LA FORME', description: 'Combattez pour votre meilleure version.', levelRequired: 54 },
    { id: 't055', name: 'CONQUÉRANT DU PHYSIQUE', description: 'Chaque jour est une victoire.', levelRequired: 55 },
    { id: 't056', name: 'PIONNIER DU BIEN-ÊTRE', description: 'Vous ouvrez la voie.', levelRequired: 56 },
    { id: 't057', name: 'PILIER DE LA VITALITÉ', description: 'Votre énergie est inépuisable.', levelRequired: 57 },
    { id: 't058', name: 'SYNTHÈSE PARFAITE', description: 'L\'équilibre est atteint.', levelRequired: 58 },
    { id: 't059', name: 'PERFORMANCE ULTIME', description: 'Vous défiez les limites.', levelRequired: 59 },
    { id: 't060', name: 'LE SOIXANTIÈME', description: 'Incroyable persévérance !', levelRequired: 60 },
    { id: 't061', name: 'LÉGENDAIRE INDOMPTABLE', description: 'Votre nom résonne.', levelRequired: 61 },
    { id: 't062', name: 'MYTHIQUE', description: 'Votre parcours est une épopée.', levelRequired: 62 },
    { id: 't063', name: 'CHRONIQUE VIVANTE', description: 'Chaque jour écrit l\'histoire.', levelRequired: 63 },
    { id: 't064', name: 'PATRON DES RECORDS', description: 'Les records s\'inclinent.', levelRequired: 64 },
    { id: 't065', name: 'LE NÉMÉSIS DE LA FAIBLESSE', description: 'Plus rien ne vous arrête.', levelRequired: 65 },
    { id: 't066', name: 'VOLONTÉ D\'ACIER', description: 'Votre détermination est inébranlable.', levelRequired: 66 },
    { id: 't067', name: 'MÉTÉORE DE LA FORME', description: 'Votre progression est fulgurante.', levelRequired: 67 },
    { id: 't068', name: 'AU-DELÀ DES LIMITES', description: 'Vous transcendez tout.', levelRequired: 68 },
    { id: 't069', name: 'VISIONNAIRE DU FITNESS', description: 'Votre vision est claire.', levelRequired: 69 },
    { id: 't070', name: 'LE SOIXANTE-DIXIÈME', description: 'Une ascension sans fin !', levelRequired: 70 },
    { id: 't071', name: 'IMMORTEL DE LA FORME', description: 'Votre dévouement est éternel.', levelRequired: 71 },
    { id: 't072', name: 'INVICTUS', description: 'Vous êtes invaincu.', levelRequired: 72 },
    { id: 't073', name: 'MAJESTÉ DU PHYSIQUE', description: 'Votre présence est imposante.', levelRequired: 73 },
    { id: 't074', name: 'SOUVERAIN DE LA SANTÉ', description: 'Vous régnez sur votre bien-être.', levelRequired: 74 },
    { id: 't075', name: 'FORCE COLISEUM', description: 'Digne d\'une arène antique.', levelRequired: 75 },
    { id: 't076', name: 'MYSTÈRE DE LA RÉUSSITE', description: 'Votre succès est fascinant.', levelRequired: 76 },
    { id: 't077', name: 'PERFECTION DE L\'ÊTRE', description: 'Corps et âme alignés.', levelRequired: 77 },
    { id: 't078', name: 'AURORE DE LA GRANDEUR', description: 'Chaque jour est un nouveau chef-d\'œuvre.', levelRequired: 78 },
    { id: 't079', name: 'COURONNE ÉTERNELLE', description: 'Votre legs perdurera.', levelRequired: 79 },
    { id: 't080', name: 'LE QUATRE-VINGTIÈME', description: 'Une légende se construit !', levelRequired: 80 },
    { id: 't081', name: 'DIEU DU FITNESS', description: 'Votre puissance est divine.', levelRequired: 81 },
    { id: 't082', name: 'TITAN DE LA FORME', description: 'Une force colossale.', levelRequired: 82 },
    { id: 't083', name: 'HÉROS ABSOLU', description: 'Vous êtes l\'incarnation du triomphe.', levelRequired: 83 },
    { id: 't084', name: 'DÉFIANT LES MORTELS', description: 'Plus rien ne vous est impossible.', levelRequired: 84 },
    { id: 't085', name: 'LE PHÉNIX DE LA SANTÉ', description: 'Vous renaissez de vos efforts.', levelRequired: 85 },
    { id: 't086', name: 'CONSTELLATION DE MUSCLES', description: 'Chaque muscle brille.', levelRequired: 86 },
    { id: 't087', name: 'L\'AURORE BORÉALE', description: 'Votre beauté est naturelle.', levelRequired: 87 },
    { id: 't088', name: 'LA FULGURANCE', description: 'Votre vitesse est inégalée.', levelRequired: 88 },
    { id: 't089', name: 'L\'INCONNU', description: 'Le monde vous attend.', levelRequired: 89 },
    { id: 't090', name: 'LE NONANTIÈME', description: 'À l\'aube de l\'immortalité !', levelRequired: 90 },
    { id: 't091', name: 'L\'ASCENSION', description: 'Vous touchez les étoiles.', levelRequired: 91 },
    { id: 't092', name: 'LA CONQUÊTE FINALE', description: 'La victoire est proche.', levelRequired: 92 },
    { id: 't093', name: 'LA PERFECTION ATTEINTE', description: 'Chaque aspect est maîtrisé.', levelRequired: 93 },
    { id: 't094', name: 'LE ZÉNITH', description: 'Vous êtes au sommet du monde.', levelRequired: 94 },
    { id: 't095', name: 'LE MYSTÈRE ÉCLAIRCI', description: 'Les secrets sont révélés.', levelRequired: 95 },
    { id: 't096', name: 'LE DESTIN ACCOMPLI', description: 'Votre destinée est scellée.', levelRequired: 96 },
    { id: 't097', name: 'L\'APOTHÉOSE', description: 'Vous êtes glorifié.', levelRequired: 97 },
    { id: 't098', name: 'L\'HÉRITAGE', description: 'Votre histoire sera contée.', levelRequired: 98 },
    { id: 't099', name: 'L\'INFINI', description: 'Les possibilités sont sans fin.', levelRequired: 99 },
    { id: 't100', name: 'MAÎTRE ULTIME DE POXEL', description: 'Félicitations, Poxel vous couronne !', levelRequired: 100 },
    { id: 't101', name: 'AU-DELÀ DE LA CENTAINE I', description: 'Une force continue.', levelRequired: 101 },
    { id: 't102', name: 'AU-DELÀ DE LA CENTAINE II', description: 'La puissance croît.', levelRequired: 102 },
    { id: 't103', name: 'AU-DELÀ DE LA CENTAINE III', description: 'L\'énergie pure.', levelRequired: 103 },
    { id: 't104', name: 'AU-DELÀ DE LA CENTAINE IV', description: 'La maîtrise s\'étend.', levelRequired: 104 },
    { id: 't105', name: 'AU-DELÀ DE LA CENTAINE V', description: 'Les profondeurs de la forme.', levelRequired: 105 },
    { id: 't106', name: 'AU-DELÀ DE LA CENTAINE VI', description: 'La discipline absolue.', levelRequired: 106 },
    { id: 't107', name: 'AU-DELÀ DE LA CENTAINE VII', description: 'Le corps résiste à tout.', levelRequired: 107 },
    { id: 't108', name: 'AU-DELÀ DE LA CENTAINE VIII', description: 'L\'esprit ne faiblit pas.', levelRequired: 108 },
    { id: 't109', name: 'AU-DELÀ DE LA CENTAINE IX', description: 'La sagesse du guerrier.', levelRequired: 109 },
    { id: 't110', name: 'AU-DELÀ DE LA CENTAINE X', description: 'Une décennie de plus de puissance !', levelRequired: 110 },
];

// Routines de sommeil adaptées aux types de poste
const sleepRoutines = {
    '6h-18h': { name: "ROUTINE JOUR (6H-18H)", details: [ "COUCHER : 22H00 - 23H00.", "RÉVEIL : 05H00 - 06H00.", "ASSURER 7-8H DE SOMMEIL DE QUALITÉ. ÉVITER LES ÉCRANS AVANT LE COUCHER." ] },
    '7h-18h': { name: "ROUTINE JOUR (7H-18H)", details: [ "COUCHER : 22H00 - 22H30.", "RÉVEIL : 06H00 - 06H15.", "OBJECTIF 7-8H DE SOMMEIL. PRIVILÉGIER UN RITUEL DE DÉTENTE PRÉ-SOMMEIL." ] },
    '18h-6h': { name: "ROUTINE NUIT (18H-6H)", details: [ "SOMMEIL PRINCIPAL APRÈS LE POSTE : 07H00 - 14H00/15H00 (7-8H).", "SIESTE PRÉ-POSTE (OPTIONNEL) : 17H00 - 17H45 (45 MIN) POUR BOOSTER LA VIGILANCE.", "UTILISER DES RIDEAUX OCCULTANTS ET UN MASQUE DE SOMMEIL POUR OPTIMISER LE REPOS EN JOURNÉE." ] },
    'repos': { name: "JOUR DE REPOS (RÉCUPÉRATION)", details: [ "MAINTENIR UN HORAIRE DE SOMMEIL PROCHE DES JOURS DE TRAVAIL POUR NE PAS PERTURBER LE RYTHME CIRCADIEN.", "COUCHER : VERS 23H00.", "RÉVEIL : VERS 08H00-09H00.", "POSSIBILITÉ DE SIÈSTE COURTE (20-30 MIN) EN DÉBUT D'APRÈS-MIDI SI NÉCESSAIRE." ] },
    'repos_sport': { name: "JOUR DE REPOS (SPORT)", details: [ "COUCHER : VERS 22H30-23H30.", "RÉVEIL : VERS 07H00-08H00.", "SOMMEIL OPTIMAL POUR LA RÉCUPÉRATION MUSCULAIRE. ÉVITER LES EXCITANTS APRÈS L'ENTRAÎNEMENT." ] }
};

// Structure par defaut du programme d'entrainement
const defaultWorkoutProgramStructure = {
    phase1: {
        name: "PHASE 1 : PROGRAMME INITIAL (POUR LES 4 À 6 PREMIÈRES SEMAINES)",
        sessions: {
            main: {
                name: "SÉANCE TYPE : RENFORCEMENT MUSCULAIRE (FULL BODY)",
                exercises: [
                    { name: "SQUAT (POIDS DU CORPS OU HALTÈRE GOBLET)", desc: "DESCENDS COMME SI TU VOULAIS T'ASSEOIR SUR UNE CHAISE, EN GARDANT LE DOS DROIT. TES GENOUX NE DOIVENT PAS DÉPASSER TES POINTES DE PIEDS.", sets: "4 SÉRIES", reps: "10-15 RÉPÉTITIONS", weight: "POIDS DU CORPS / 4-10 KG", rest: "60-90 SECONDES", type: "legs" },
                    { name: "POMPES (PUSH-UPS)", desc: "GARDE LE CORPS DROIT (PLANCHE). DESCENDS TA POITRINE VERS LE SOL ET POUSSE. PROGRESSION : COMMENCE SUR LES GENOUX OU CONTRE UN MUR/BANC, PUIS AU SOL.", sets: "3-4 SÉRIES", reps: "MAX DE RÉPÉTITIONS", weight: "POIDS DU CORPS", rest: "60-90 SECONDES", type: "chest" },
                    { name: "LAT PULLDOWN (POULIE HAUTE)", desc: "ASSIEDS-TOI, SAISIS LA BARRE AVEC UNE PRISE LARGE. TIRE LA BARRE VERS TA POITRINE, EN CONTRACTANT LE DOS.", sets: "3-4 SÉRIES", reps: "10-15 RÉPÉTITIONS", weight: "25-35 KG", rest: "60-90 SECONDES", type: "back" },
                    { name: "DÉVELOPPÉ COUCHÉ HALTÈRES OU PEC DECK", desc: "HALTÈRES (SUR BANC) : ALLONGÉ, UN HALTÈRE DANS CHAQUE MAIN AU NIVEAU DE LA POITRINE. POUSSE LES HALTÈRES VERS LE HAUT. PEC DECK : ASSIEDS-TOI, SAISIS LES POIGNÉES. POUSSE VERS L'AVANT EN CONTRACTANT LA POITRINE.", sets: "3-4 SÉRIES", reps: "10-15 RÉPÉTITIONS", weight: "6-10 KG / 15-25 KG", rest: "60-90 SECONDES", type: "chest" },
                    { name: "FENTES (LUNGES)", desc: "FAIS UN GRAND PAS EN AVANT, DESCENDS LE GENOU ARRIÈRE VERS LE SOL (SANS LE TOUCHER). GARDE LE CORPS DROIT. REMONTE EN POUSSANT SUR LA JAMBE AVANT.", sets: "3 SÉRIES", reps: "8-12 RÉPÉTITIONS PAR JAMBE", weight: "POIDS DU CORPS / 4-6 KG", rest: "60-90 SECONDES", type: "legs" },
                    { name: "ÉLÉVATIONS LATÉRALES (HALTÈRES)", desc: "TIENS UN HALTÈRE LÉGER DANS CHAQUE MAIN, BRAS LE LONG DU CORPS. LÈVE LES BRAS SUR LES CÔTÉS, LÉGÈREMENT FLÉCHIS, JUSQU'À L'HORIZONTAL.", sets: "3 SÉRIES", reps: "12-15 RÉPÉTITIONS", weight: "2-4 KG", rest: "60-90 SECONDES", type: "shoulders" },
                    { name: "PLANCHE (PLANK)", desc: "SUR LES AVANT-BRAS ET LES POINTES DE PIEDS (OU SUR LES GENOUX SI TROP DIFFICILE), GARDE TON CORPS DROIT ET CONTRACTÉ COMME UNE PLANCHE.", sets: "3 SÉRIES", reps: "30-60 SECONDES", weight: "POIDS DU CORPS", rest: "60 SECONDES", type: "core" }
                ]
            },
            cardio: {
                name: "SÉANCE TYPE : CARDIO (ENDURANCE, FRACTIONNÉ OU MIXTE)",
                options: [
                    {
                        name: "TAPIS DE COURSE (FRACTIONNÉ)",
                        desc: "RONDE 1 : 2 MIN MARCHE RAPIDE, 1 MIN COURSE LÉGÈRE. RONDE 2 : 2 MIN MARCHE RAPIDE, 1 MIN COURSE LÉGÈRE.",
                        sets: "2 RONDES", reps: "15 MINUTES PAR RONDE", weight: "N/A", rest: "5 MINUTES ENTRE LES RONDES", type: "cardio"
                    },
                    {
                        name: "VÉLO STATIONNAIRE OU VÉLO ELLIPTIQUE (SYNCHRO) (FRACTIONNÉ)",
                        desc: "RONDE 1 : 3 MIN MODÉRÉ, 1 MIN INTENSE. RONDE 2 : 3 MIN MODÉRÉ, 1 MIN INTENSE.",
                        sets: "2 RONDES", reps: "20 MINUTES PAR RONDE", weight: "N/A", rest: "5 MINUTES ENTRE LES RONDES", type: "cardio"
                    },
                    {
                        name: "CARDIO &amp; FONCTIONNEL MIXTE (MOINS INTENSE QU'UN HIIT)",
                        desc: "PARTIE 1 : TAPIS/VÉLO &amp; MOUNTAIN CLIMBERS/JUMPING JACKS. PARTIE 2 : TAPIS/VÉLO &amp; MONTÉES DE GENOUX/KETTLEBELL SWING.",
                        sets: "2 PARTIES", reps: "20 MIN / 15 MIN", weight: "N/A", rest: "5 MINUTES ENTRE LES PARTIES", type: "cardio"
                    }
                ]
            },
            hiit: {
                name: "SÉANCE TYPE : HIIT (HIGH-INTENSITY INTERVAL TRAINING)",
                desc: "DURÉE ESTIMÉE : 30-40 MINUTES. FRÉQUENCE : 1 À 2 FOIS PAR SEMAINE MAXIMUM. ATTENTION : LE HIIT EST INTENSE. ÉCOUTE IMPÉRATIVEMENT TON CORPS. LES JOURS OÙ LA FATIGUE LIÉE À TA SEP EST PLUS PRÉSENTE, REMPLACE CETTE SÉANCE PAR DU CARDIO LÉGER OU DU REPOS ACTIF. CORPS DE SÉANCE (20-25 MINUTES) : RÉALISE 3 À 4 TOURS DU CIRCUIT SUIVANT. CHAQUE EXERCICE : 40 SECONDES D'EFFORT MAXIMAL, SUIVIES DE 20 SECONDES DE REPOS TOTAL. ENTRE CHAQUE TOUR COMPLET DU CIRCUIT : 1 MINUTE 30 DE REPOS ACTIF (MARCHE LÉGÈRE, HYDRATATION).",
                exercises: [
                    { name: "BURPEES (MODIFIÉS)", desc: "DESCENDS EN SQUAT, POSE LES MAINS AU SOL, JETTE LES JAMBES EN ARRIÈRE POUR TE METTRE EN PLANCHE (SANS POMPE SI TU DÉBUTTES), RAMÈNE LES PIEDS ENTRE LES MAINS, RELÈVE-TOI.", sets: "1 SÉRIE", reps: "40 SECONDES", weight: "POIDS DU CORPS", rest: "20 SECONDES", type: "hiit" },
                    { name: "MOUNTAIN CLIMBERS", desc: "EN POSITION DE PLANCHE, RAMÈNE ALTERNATIVEMENT LES GENOUX VERS LA POITRINE, COMME SI TU 'COURAIS' SUR PLACE.", sets: "1 SÉRIE", reps: "40 SECONDES", weight: "POIDS DU CORPS", rest: "20 SECONDES", type: "hiit" },
                    { name: "JUMPING JACKS", desc: "SAUTE EN ÉCARTANT LES JAMBES ET EN LEVANT LES BRAS AU-DESSUS DE LA TÊTE, PUIS REVIENS EN POSITION INITIALE. (SI LES SAUTS SONT TROP INTENSES, FAIS UN PAS SUR LE CÔTÉ AVEC UN BRAS QUI MONTE, PUIS L'AUTRE).", sets: "1 SÉRIE", reps: "40 SECONDES", weight: "POIDS DU CORPS", rest: "20 SECONDES", type: "hiit" },
                    { name: "KETTLEBELL SWING", desc: "MOUVEMENT DE BALANCIER EN POUSSANT LES HANCHES VERS L'AVANT (PAS AVEC LES BRAS !).", sets: "1 SÉRIE", reps: "40 SECONDES", weight: "6-10 KG", rest: "20 SECONDES", type: "hiit" },
                    { name: "FENTES SAUTÉES", desc: "SAUTE POUR CHANGER DE JAMBE EN L'AIR ET ATTERRIS EN FENTE AVEC L'AUTRE JAMBE DEVANT. MODIFICATION : SI LES SAUTS SONT TROP INTENSES, FAIS DES FENTES ALTERNÉES CLASSIQUES EN TE RELÈVANT RAPIDEMENT ENTRE CHAQUE.", sets: "1 SÉRIE", reps: "40 SECONDES", weight: "POIDS DU CORPS", rest: "20 SECONDES", type: "hiit" },
                    { name: "MONTÉES DE GENOUX RAPIDES", desc: "COURS SUR PLACE EN LEVANT LES GENOUX LE PLUS HAUT POSSIBLE, EN UTILISANT TES BRAS.", sets: "1 SÉRIE", reps: "40 SECONDES", weight: "POIDS DU CORPS", rest: "20 SECONDES", type: "hiit" }
                ]
            }
        }
    },
    phase2: {
        name: "PHASE 2 : PROGRAMME ALTERNATIF (POUR LES 4 À 6 SEMAINES SUIVANTES)",
        sessions: {
            main: {
                name: "SÉANCE TYPE : RENFORCEMENT MUSCULAIRE (FULL BODY) - ALTERNATIVE",
                exercises: [
                    { name: "SOULEVÉ DE TERRE ROUMAIN (RDL HALTÈRES)", desc: "TIENS UN HALTÈRE DANS CHAQUE MAIN, PIEDS LARGEUR DES HANCHES. DESCENDS LES HALTÈRES LE LONG DE TES JAMBES EN POUSSANT LES HANCHES VERS L'ARRIÈRE ET EN GARDANT LE DOS DROIT.", sets: "4 SÉRIES", reps: "10-15 RÉPÉTITIONS", weight: "6-10 KG", rest: "60-90 SECONDES", type: "legs" },
                    { name: "TRACTIONS ASSISTÉES (MACHINE)", desc: "TIRE TON CORPS VERS LE HAUT JUSQU'À CE QUE TON MENTON DÉPASSE LA BARRE, EN CONTRACTANT LE DOS. ASSISTANCE : UTILISE LA MACHINE AVEC UN POIDS D'ASSISTANCE ÉLEVÉ, OU UN ÉLASTIQUE ÉPAIS.", sets: "3-4 SÉRIES", reps: "MAX DE RÉPÉTITIONS", weight: "N/A", rest: "60-90 SECONDES", type: "back" },
                    { name: "PRESSE À CUISSES (LEG PRESS)", desc: "POUSSE LA PLATEFORME EN ÉTENDANT LES JAMBES, SANS BLOQUER LES GENOUX.", sets: "3-4 SÉRIES", reps: "10-15 RÉPÉTITIONS", weight: "40-60 KG", rest: "60-90 SECONDES", type: "legs" },
                    { name: "DÉVELOPPÉ ÉPAULES (SHOULDER PRESS HALTÈRES OU MACHINE)", desc: "ASSISE, UN HALTÈRE DANS CHAQUE MAIN AU NIVEAU DES ÉPAULES. POUSSE LES HALTÈRES VERS LE HAUT AU-DESSUS DE TA TÊTE.", sets: "3-4 SÉRIES", reps: "10-15 RÉPÉTITIONS", weight: "4-8 KG / 10-20 KG", rest: "60-90 SECONDES", type: "shoulders" },
                    { name: "ROWING PENCHÉ (HALTÈRES)", desc: "TIENS UN HALTÈRE DANS CHAQUE MAIN, PENCHE LE BUSTE EN AVANT (DOS DROIT, GENOUX LÉGÈREMENT FLÉCHIS). TIRE LES HALTÈRES VERS TA POITRINE EN CONTRACTANT LES OMOPLATES.", sets: "3 SÉRIES", reps: "10-15 RÉPÉTITIONS", weight: "6-10 KG", rest: "60-90 SECONDES", type: "back" },
                    { name: "EXTENSIONS TRICEPS (POULIE HAUTE OU HALTÈRE)", desc: "POULIE : COUDES COLLÉS AU CORPS. POUSSE LA BARRE VERS LE BAS EN NE BOUGEANT QUE L'AVANT-BRAS. HALTÈRE (DERRIÈRE LA TÊTE) : TIENS UN HALTÈRE AVEC LES DEUX MAINS DERRIÈRE TA TÊTE, POUSSE VERS LE HAUT.", sets: "3 SÉRIES", reps: "12-15 RÉPÉTITIONS", weight: "10-15 KG / 4-8 KG", rest: "60-90 SECONDES", type: "arms" },
                    { name: "CRUNCHS (ABDOMINALS)", desc: "LÈVE LES ÉPAULES DU SOL EN CONTRACTANT LES ABDOMINAUX, SANS TIRER SUR LA NUQUE.", sets: "3 SÉRIES", reps: "15-20 RÉPÉTITIONS", weight: "POIDS DU CORPS", rest: "30 SECONDES", type: "core" }
                ]
            },
            cardio: {
                name: "SÉANCE TYPE : CARDIO (ENDURANCE, FRACTIONNÉ OU MIXTE) - ALTERNATIVE",
                options: [
                    {
                        name: "TAPIS DE COURSE (ENDURANCE À PENTE VARIABLE)",
                        desc: "5 MIN ÉCHAUFFEMENT LÉGER. RONDE 1 : 2 MIN MARCHE RAPIDE, 3 MIN MARCHE RAPIDE, 2 MIN COURSE LÉGÈRE.",
                        sets: "1 SÉRIE", reps: "40-50 MINUTES", weight: "N/A", rest: "N/A", type: "cardio"
                    },
                    {
                        name: "RAMEUR (ROWING MACHINE) - INTERVAL TRAINING",
                        desc: "5 MIN ÉCHAUFFEMENT LÉGER. RONDE 1 : 2 MIN MODÉRÉ, 1 MIN INTENSE. RONDE 2 : 3 MIN MODÉRÉ, 1 MIN INTENSE.",
                        sets: "2 RONDES", reps: "15 MINUTES PAR RONDE", weight: "N/A", rest: "5 MINUTES ENTRE LES RONDES", type: "cardio"
                    },
                    {
                        name: "CARDIO &amp; FONCTIONNEL MIXTE (ALTERNATIF)",
                        desc: "PARTIE 1 : RAMEUR/ELLIPTIQUE &amp; SQUAT/FENTES. PARTIE 2 : TAPIS/VÉLO &amp; BURPEES/CORDE À SAUTER.",
                        sets: "2 PARTIES", reps: "20 MIN / 15 MIN", weight: "N/A", rest: "N/A", type: "cardio"
                    }
                ]
            },
            hiit: {
                name: "SÉANCE TYPE : HIIT (HIGH-INTENSITY INTERVAL TRAINING) - ALTERNATIVE",
                desc: "DURÉE ESTIMÉE : 30-40 MINUTES. FRÉQUENCE : 1 À 2 FOIS PAR SEMAINE MAXIMUM. ATTENTION : LE HIIT EST INTENSE. ÉCOUTE IMPÉRATIVEMENT TON CORPS. LES JOURS OÙ LA FATIGUE LIÉE À TA SEP EST PLUS PRÉSENTE, REMPLACE CETTE SÉANCE PAR DU CARDIO LÉGER OU DU REPOS ACTIF. CORPS DE SÉANCE (20-25 MINUTES) : RÉALISE 3 À 4 TOURS DU CIRCUIT SUIVANT. CHAQUE EXERCICE : 45 SECONDES D'EFFORT INTENSE, SUIVIES DE 15 SECONDES DE REPOS TOTAL. ENTRE CHAQUE TOUR COMPLET DU CIRCUIT : 1 MINUTE 15 DE REPOS ACTIF (MARCHE LÉGÈRE, HYDRATATION).",
                exercises: [
                    { name: "BURPEES (AVEC POMPE)", desc: "FAIS UN BURPEE COMPLET, EN INCLUANT UNE POMPE (SUR LES GENOUX SI BESOIN) LORSQUE TU ES EN POSITION DE PLANCHE.", sets: "1 SÉRIE", reps: "45 SECONDES", weight: "POIDS DU CORPS", rest: "15 SECONDES", type: "hiit" },
                    { name: "BOX JUMPS OU STEP-UPS", desc: "SAUTE SUR UNE BOÎTE BASSE (OU UN STEP) ET DESCENDS. SI LES SAUTS SONT UN PROBLÈME : FAIS DES STEP-UPS RAPIDES (MONTE ET DESCENDS DU BANC UNE JAMBE APRÈS L'AUTRE).", sets: "1 SÉRIE", reps: "45 SECONDES", weight: "POIDS DU CORPS", rest: "15 SECONDES", type: "hiit" },
                    { name: "CORDE À SAUTER", desc: "SAUTE À LA CORDE. VARIE LES SAUTS (PIEDS JOINTS, ALTERNÉS). SI PAS DE CORDE OU TROP DIFFICILE : FAIS DES SAUTS SUR PLACE LÉGERS OU DES PAS CHASSÉS RAPIDES.", sets: "1 SÉRIE", reps: "45 SECONDES", weight: "POIDS DU CORPS", rest: "15 SECONDES", type: "hiit" },
                    { name: "KETTLEBELL GOBLET SQUAT (EXPLOSIF)", desc: "TIENS UN KETTLEBELL DEVANT TA POITRINE. FAIS UN SQUAT COMPLET ET REMONTE DE MANIÈRE EXPLOSIVE.", sets: "1 SÉRIE", reps: "45 SECONDES", weight: "8-12 KG", rest: "15 SECONDES", type: "hiit" },
                    { name: "MOUNTAIN CLIMBERS CROISÉS", desc: "EN POSITION DE PLANCHE, RAMÈNE LE GENOU DROIT VERS LE COUDE GAUCHE, PUIS LE GENOU GAUCHE VERS LE COUDE DROIT, EN ALTERNANCE RAPIDE.", sets: "1 SÉRIE", reps: "45 SECONDES", weight: "POIDS DU CORPS", rest: "15 SECONDES", type: "hiit" },
                    { name: "SAUTS LATÉRAUX (LATERAL JUMPS)", desc: "SAUTE DE DROITE À GAUCHE RAPIDEMENT AU-DESSUS D'UNE LIGNE IMAGINAIRE OU D'UN PETIT OBJET.", sets: "1 SÉRIE", reps: "45 SECONDES", weight: "POIDS DU CORPS", rest: "15 SECONDES", type: "hiit" }
                ]
            }
        }
    },
    recovery: {
        name: "JOURNÉE DE RÉCUPÉRATION ACTIVE / FLEXIBILITÉ (OPTIONNEL)",
        desc: "EN PLUS DE TES JOURS DE REPOS COMPLETS, TU PEUX DÉDIER UNE JOURNÉE PAR SEMAINE À UNE ACTIVITÉ DOUCE POUR LA RÉCUPÉRATION ET LA SOUPLESSE.",
        activities: [
            { name: "MARCHE PROLONGÉE", desc: "DANS UN PARC, EN NATURE, À UN RYTHME AGRÉABLE (45-60 MIN).", sets: "1 SÉRIE", reps: "45-60 MINUTES", weight: "N/A", rest: "N/A" },
            { name: "SÉANCE DE YOGA DOUX OU DE PILATES", desc: "PRIVILÉGIE LES VIDÉOS EN LIGNE POUR DÉBUTANTS AXÉES SUR LA FLEXIBILITÉ ET LE RENFORCEMENT DU TRONC.", sets: "1 SÉRIE", reps: "30-45 MINUTES", weight: "N/A", rest: "N/A" },
            { name: "ÉTIREMENTS PROFONDS", desc: "UNE SÉANCE DÉDIÉE DE 20-30 MINUTES POUR ÉTIRER TOUS LES GRANDS GROUPES MUSCULAIRES, EN MAINTENANT LES POSITIONS PLUS LONGTEMPS (30-60 SEC).", sets: "1 SÉRIE", reps: "20-30 MINUTES", weight: "N/A", rest: "N/A" },
            { name: "NATATION LÉGÈRE", desc: "QUELQUES LONGUEURS À RYTHME TRANQUILLE POUR DÉTENDRE LES MUSCLES.", sets: "1 SÉRIE", reps: "30-45 MINUTES", weight: "N/A", rest: "N/A" }
        ]
    }
};

// Fonctions utilitaires pour la persistance des données dans le localStorage
function saveToLocalStorage(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); console.log(`[LocalStorage] Données sauvegardées pour '${key}'.`); } catch (e) { console.error(`[LocalStorage] Erreur lors de la sauvegarde pour '${key}':`, e); showMessage(`ERREUR: Impossible de sauvegarder ${key}.`, 'error'); } }
function loadFromLocalStorage(key, defaultValue) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : defaultValue; } catch (e) { console.error(`[LocalStorage] Erreur lors du chargement pour '${key}':`, e); showMessage(`ATTENTION: Données corrompues pour ${key}. Chargement par défaut.`, 'warning'); return defaultValue; } }
function removeFromLocalStorage(key) { try { localStorage.removeItem(key); console.log(`[LocalStorage] Données supprimées pour '${key}'.`); } catch (e) { console.error(`[LocalStorage] Erreur lors de la suppression pour '${key}':`, e); showMessage(`ERREUR: Impossible de supprimer ${key}.`, 'error'); } }

// Initialisation de l'état global de l'application au démarrage
function initializeGlobalState() {
    console.log("[INITIALISATION] Chargement de l'état global depuis le localStorage...");
    userProfile = loadFromLocalStorage('userProfile', { height: '', weight: '', imc: null, imcCategory: '', proteinNeeds: 'N/A', currentXP: 0, earnedTrophies: [], hideExerciseHistory: false, apiKey: '', likedMeals: [], dislikedMeals: [], customNutritionalProgramText: '', customWorkoutProgramJSON: '' });
    if (!Array.isArray(userProfile.likedMeals)) userProfile.likedMeals = [];
    if (!Array.isArray(userProfile.dislikedMeals)) userProfile.dislikedMeals = [];
    // Charger les programmes personnalisés, sinon utiliser les valeurs par défaut
    nutritionalProgramText = userProfile.customNutritionalProgramText || nutritionalProgramText;
    try {
        workoutProgram = userProfile.customWorkoutProgramJSON ? JSON.parse(userProfile.customWorkoutProgramJSON) : JSON.parse(JSON.stringify(defaultWorkoutProgramStructure));
    } catch (e) {
        console.error("Erreur lors du parsing du programme sportif personnalisé, chargement du programme par défaut.", e);
        showMessage("ERREUR: PROGRAMME SPORTIF PERSONNALISÉ CORROMPU. CHARGEMENT DU PROGRAMME PAR DÉFAUT.", 'error');
        workoutProgram = JSON.parse(JSON.stringify(defaultWorkoutProgramStructure));
    }

    weeklyMealPlan = loadFromLocalStorage('weeklyMealPlan', { semaine: [] });
    workoutLogs = loadFromLocalStorage('workoutLogs', []);
    weightHistory = loadFromLocalStorage('weightHistory', []);
    intervalSequences = loadFromLocalStorage('intervalSequences', []);
    shifts = loadFromLocalStorage('shifts', []);
    workoutProgram = loadFromLocalStorage('savedWorkoutProgram', JSON.parse(JSON.stringify(defaultWorkoutProgramStructure)));
    previousLevel = calculateLevelAndXP(userProfile.currentXP).level;
    const savedChronoState = loadFromLocalStorage('chronoState', {});
    chronoIntervals = savedChronoState.intervals || [];
    chronoCurrentTime = savedChronoState.currentTime || 0;
    chronoCurrentIntervalIndex = savedChronoState.currentIntervalIndex !== undefined ? savedChronoState.currentIntervalIndex : -1;
    isChronoRunning = savedChronoState.isRunning || false;
    isChronoPaused = savedChronoState.isPaused || false;
    enableChronoPreCountdown = savedChronoState.enablePreCountdown !== undefined ? savedChronoState.enablePreCountdown : true;
    chronoPreCountdownDuration = savedChronoState.preCountdownDuration || 10;
    if (!Array.isArray(userProfile.earnedTrophies)) userProfile.earnedTrophies = [];

    // Load numPeople and allowMeatFish
    numPeople = loadFromLocalStorage('recipeNumPeople', 1);
    allowMeatFish = loadFromLocalStorage('recipeAllowMeatFish', true);
    if (!Array.isArray(userProfile.earnedTrophies)) userProfile.earnedTrophies = [];

// Load numPeople and allowMeatFish
numPeople = loadFromLocalStorage('recipeNumPeople', 1);
allowMeatFish = loadFromLocalStorage('recipeAllowMeatFish', true);
preferPowderedProtein = loadFromLocalStorage('preferPowderedProtein', false); // Charge la nouvelle préférence
// Charger les données du calendrier sportif
sportProgramCalendar = loadFromLocalStorage('sportProgramCalendar', {
    startDate: new Date().toISOString().split('T')[0], // Date du jour
    weeks: {} // Contiendra { 'YYYY-MM-DD': { completed: true, sessions: 3, phase: 'phase1' } }
});
totalProgramWeeks = loadFromLocalStorage('totalProgramWeeks', 12);
currentProgramPhase = loadFromLocalStorage('currentProgramPhase', 'phase1');

    console.log("[INITIALISATION] État global chargé.");
}

// Met à jour l'état du chronomètre dans le localStorage
function updateLocalStorageChronoState() { saveToLocalStorage('chronoState', { intervals: chronoIntervals, currentTime: chronoCurrentTime, currentIntervalIndex: chronoCurrentIntervalIndex, isRunning: isChronoRunning, isPaused: isChronoPaused, enablePreCountdown: enableChronoPreCountdown, preCountdownDuration: chronoPreCountdownDuration }); }
    // Calcule et affiche la durée totale de tous les intervalles (maintenant globale)
    // Calcule et affiche la durée totale de tous les intervalles (maintenant avec secondes)
function updateTotalIntervalDurationDisplay() {
    let totalSeconds = 0;
    chronoIntervals.forEach(interval =&gt; {
        totalSeconds += interval.duration;
    });

    const totalMinutes = Math.floor(totalSeconds / 60);
    const remainingSeconds = totalSeconds % 60;

    const totalDurationDisplay = totalDurationDisplayElement; // Utilise la variable globale

    if (totalDurationDisplay) {
        if (remainingSeconds &gt; 0) {
            totalDurationDisplay.textContent = `${totalMinutes} minutes et ${remainingSeconds} secondes`;
        } else {
            // Si le nombre de secondes est 0, on peut choisir d'afficher juste les minutes
            totalDurationDisplay.textContent = `${totalMinutes} minutes`;
        }
    }
}


    // Rend la liste des intervalles (maintenant avec secondes affichées)
function renderIntervalsList() {
    console.log("[renderIntervalsList] Début du rendu. État actuel de chronoIntervals:", JSON.parse(JSON.stringify(chronoIntervals))); // DEBUG
    let listHtml = '';
    if (chronoIntervals.length === 0) listHtml = '&lt;p class="text-gray-400"&gt;AUCUN INTERVALLE AJOUTÉ.&lt;/p&gt;';
    else {
        listHtml = `&lt;ul class="space-y-2"&gt;`;
        chronoIntervals.forEach((interval, index) =&gt; {
            const minutes = Math.floor(interval.duration / 60);
            const seconds = interval.duration % 60;
            const formattedSeconds = String(seconds).padStart(2, '0'); // Ajoute un zéro devant si &lt; 10

            listHtml += `
                &lt;li class="flex flex-col sm:flex-row justify-between items-start sm:items-center bg-[#131313] p-2 rounded-md border border-gray-700"&gt;
                    &lt;span class="text-gray-100 text-base sm:text-lg"&gt;${minutes}:${formattedSeconds} - ${String(interval.instruction).toUpperCase()}&lt;/span&gt;
                    &lt;div class="flex gap-2 mt-2 sm:mt-0"&gt;
                        &lt;button class="btn-retro-green text-xs px-2 py-1 duplicate-interval-btn" data-index="${index}"&gt;DUPLIQUER&lt;/button&gt;
                        &lt;button class="btn-retro-purple text-xs px-2 py-1 edit-interval-btn" data-index="${index}"&gt;MODIFIER&lt;/button&gt;
                        &lt;button class="btn-retro-red text-xs px-2 py-1 remove-interval-btn" data-index="${index}"&gt;SUPPRIMER&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/li&gt;
            `;
        });
        listHtml += `&lt;/ul&gt;`;
    }
    intervalsListDiv.innerHTML = listHtml; // Utilise la variable globale
    updateTotalIntervalDurationDisplay(); // Appel direct de la fonction globale


    intervalsListDiv.querySelectorAll('.remove-interval-btn').forEach(button =&gt; {
        button.onclick = async (event) =&gt; {
            const indexToRemove = parseInt(event.target.dataset.index);
            if (await showConfirmModal("CONFIRMER LA SUPPRESSION DE L'INTERVALLE ?")) {
                chronoIntervals.splice(indexToRemove, 1);
                updateLocalStorageChronoState();
                showMessage("INTERVALLE SUPPRIMÉE !", 'success');
                renderIntervalsList();
                resetIntervalForm();
            }
        };
    });


    intervalsListDiv.querySelectorAll('.duplicate-interval-btn').forEach(button =&gt; {
        button.onclick = async (event) =&gt; {
            const indexToDuplicate = parseInt(event.target.dataset.index);
            const originalInterval = chronoIntervals[indexToDuplicate];
            if (originalInterval) {
                chronoIntervals.push({ ...originalInterval });
                updateLocalStorageChronoState();
                showMessage("INTERVALLE DUPLIQUÉE !", 'success');
                renderIntervalsList();
            }
        };
    });


    intervalsListDiv.querySelectorAll('.edit-interval-btn').forEach(button =&gt; {
        button.onclick = (event) =&gt; {
            const indexToEdit = parseInt(event.target.dataset.index);
            showEditIntervalModal(indexToEdit);
        };
    });
    console.log("[renderIntervalsList] Rendu terminé."); // DEBUG
}


    // Réinitialise les champs du formulaire d'intervalle (maintenant globale)
    function resetIntervalForm() {
    newDurationMinutesInput.value = '0'; // Réinitialise les minutes à 0
    newDurationSecondsInput.value = '0'; // Réinitialise les secondes à 0
    newInstructionInput.value = '';
    addUpdateIntervalBtn.textContent = 'AJOUTER';
    addUpdateIntervalBtn.classList.remove('btn-retro-purple');
    addUpdateIntervalBtn.classList.add('btn-retro');
    // editingIntervalIndex n'est plus utilisé par ce formulaire, mais on le réinitialise
    // par sécurité si d'autres parties du code le consultent.
    editingIntervalIndex = -1; // S'assure que l'état d'édition est réinitialisé
}

    
    // Affiche un message de notification à l'utilisateur
    function showMessage(msg, type = 'info') {
        const container = document.getElementById('notification-container-bottom-right');
        const notification = document.createElement('div');
        notification.className = `notification general ${type}`;
        const iconMap = { 'success': '🎉', 'error': '❌', 'warning': '⚠️', 'info': 'ℹ️', 'chrono': '⏱️', 'tip': '💡', 'ai-advice': '🤖' }; // Ajout de 'ai-advice'
        notification.innerHTML = `&lt;span class="text-2xl"&gt;${iconMap[type] || 'ℹ️'}&lt;/span&gt;&lt;p class="font-bold text-sm sm:text-base"&gt;${String(msg).toUpperCase()}&lt;/p&gt;`;

        // --- DÉBUT DES MODIFICATIONS POUR LA SUPERPOSITION DES NOTIFICATIONS DE SUCCÈS ---
        if (type === 'success') {
            // Supprime toutes les notifications de succès existantes pour qu'une seule soit visible et la "recouvre"
            // Itérer à l'envers pour supprimer des éléments d'une collection vivante sans casser l'itération
            for (let i = container.children.length - 1; i &gt;= 0; i--) {
                const existingNotif = container.children[i];
                // Vérifie si c'est une notification et si elle a la classe 'success'
                if (existingNotif.classList.contains('notification') &amp;&amp; existingNotif.classList.contains('success')) {
                    existingNotif.remove();
                }
            }
            // Pour les notifications de succès, on l'ajoute simplement à la fin du conteneur.
            // La logique de positionnement dans la boucle suivante la placera correctement
            // et comme elle est la seule de son type, elle sera "par-dessus" d'anciennes.
            container.appendChild(notification); // MODIFIÉ: Appendre plutôt qu'insérer au début
        } else {
            // Pour les autres types de notifications, on les insère au début pour qu'elles apparaissent en haut de la pile visuellement
            container.insertBefore(notification, container.firstChild);
        }
        // --- FIN DES MODIFICATIONS ---

        // La logique de positionnement vertical reste la même pour tous les types après insertion
        let currentBottom = 0;
        // Collecter les notifications dans l'ordre d'affichage (du bas vers le haut visuellement)
        const notificationsInOrder = Array.from(container.children).reverse();

        notificationsInOrder.forEach((notif, index) =&gt; {
            // Seulement ajuster la position des notifications qui sont actives et visibles
            // ou la nouvelle notification qui vient d'être ajoutée.
            if (notif.classList.contains('notification')) { // S'assurer que c'est bien un élément de notification
                notif.style.bottom = `${currentBottom}px`;
                // Appliquer l'animation de slide-in
                if (notif === notification) { // C'est la nouvelle notification
                    notif.style.right = '20px'; // Position de départ à droite
                    void notif.offsetWidth; // Force le reflow avant l'animation
                    notif.classList.add('show');
                    notif.style.transform = 'translateX(0)'; // Fait glisser de droite à gauche
                } else if (notif.classList.contains('show')) { // Notifications déjà affichées
                    // S'assurer qu'elles restent à leur position horizontale
                    notif.style.transform = 'translateX(0)';
                }
                currentBottom += notif.offsetHeight + 10; // 10px de gap entre les notifications
            }
        });

        const duration = type === 'trophy' ? 12000 : (type === 'tip' ? 20000 : (type === 'ai-advice' ? 15000 : 5000));

        setTimeout(() =&gt; {
            notification.style.transform = 'translateX(100%)'; // Fait disparaître vers la droite
            notification.style.opacity = '0';
            notification.addEventListener('transitionend', function handler() {
                notification.remove(); // Supprime l'élément du DOM après la transition
                // Réajuster les positions des notifications restantes après la suppression
                // Seulement si la notification supprimée n'était PAS une notification de succès.
                // Pour les succès, on veut qu'elle disparaisse et c'est tout, la suivante gérera le placement.
                if (type !== 'success') {
                    let reAdjustBottom = 0;
                    // Filtrer pour ne réajuster que les notifications qui sont encore là, visibles, et qui ne sont pas de type 'success'
                    Array.from(container.children).reverse().forEach(notif =&gt; {
                        if (notif.classList.contains('notification') &amp;&amp; notif.classList.contains('show') &amp;&amp; !notif.classList.contains('success')) {
                            notif.style.bottom = `${reAdjustBottom}px`;
                            reAdjustBottom += notif.offsetHeight + 10;
                        }
                    });
                }
                notification.removeEventListener('transitionend', handler); // Nettoyer l'écouteur
            }, { once: true });
        }, duration);
    }
// Fonction pour gérer l'action "J'aime pas" sur un repas (maintenant avec bascule)
async function handleDislikeMeal(mealObject) { // Prend l'objet repas complet
    if (!mealObject || !mealObject.id) {
        console.error("Tentative de 'dislike' un repas sans objet ou ID valide.");
        showMessage('ERREUR: REPAS INVALIDE.', 'error');
        return;
    }

    // Vérifie si le repas est déjà dans la liste des repas non aimés
    const dislikedIndex = userProfile.dislikedMeals.findIndex(dm =&gt; dm.id === mealObject.id);

    if (dislikedIndex !== -1) {
        // Le repas est déjà "non aimé", donc on le retire de la liste
        userProfile.dislikedMeals.splice(dislikedIndex, 1);
        showMessage('Repas retiré de votre liste "J\'aime pas".', 'info');
    } else {
        // Le repas n'est pas "non aimé", donc on l'ajoute à la liste
        userProfile.dislikedMeals.push({
            id: mealObject.id,
            title: mealObject.title,
            description_du_plat: mealObject.description_du_plat,
            ingredients_list: mealObject.ingredients_list,
            mealType: mealObject.mealType,
            dayContext: mealObject.dayContext,
            dislikedAt: new Date().toISOString() // Ajoute un horodatage
        });
        // Si le repas était "aimé", on le retire de la liste des "aimés"
        // Un repas ne peut pas être à la fois "aimé" et "non aimé"
        userProfile.likedMeals = userProfile.likedMeals.filter(id =&gt; id !== mealObject.id);
        showMessage('Repas ajouté à votre liste "J\'aime pas".', 'success');
    }

    // Sauvegarde le profil utilisateur après la modification
    saveToLocalStorage('userProfile', userProfile);
    // Re-rend la page pour mettre à jour l'affichage (la couleur de la croix)
    renderPage(currentPage);
}
// Affiche une notification de trophée débloqué
function showTrophyNotification(trophyName, description) {
    const container = document.getElementById('notification-container-bottom-right');
    const notification = document.createElement('div');
    notification.className = 'notification general success';
    notification.innerHTML = `&lt;span class="text-4xl"&gt;🏆&lt;/span&gt;&lt;div&gt;&lt;p class="font-bold text-lg sm:text-xl"&gt;TROPHÉE DÉBLOQUÉ !&lt;/p&gt;&lt;p class="text-yellow-300 text-sm sm:text-base"&gt;${String(trophyName).toUpperCase()}&lt;/p&gt;&lt;p class="text-gray-200 text-xs sm:text-sm"&gt;${String(description).toUpperCase()}&lt;/p&gt;&lt;/div&gt;`;
    container.appendChild(notification);
    playTrophySound();
    void notification.offsetWidth; // Force reflow for animation
    setTimeout(() =&gt; { notification.classList.add('show'); }, 100);
    setTimeout(() =&gt; { notification.classList.remove('show'); notification.addEventListener('transitionend', () =&gt; notification.remove(), { once: true }); }, 12000);
}

// Gestion du contexte audio pour les effets sonores
let audioContextStartedOnce = false;
async function initializeAudioContextNonBlocking() {
    if (Tone.context.state === 'running' || audioContextStartedOnce) return;
    try {
        await Tone.start();
        audioContextStartedOnce = true;
        isAudioActive = true;
        Tone.Master.mute = false;
        Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
    } catch (e) {
        isAudioActive = false;
        Tone.Master.mute = true;
    }
}

// Gère le geste de l'utilisateur pour démarrer l'audio
function handleUserGestureToStartAudio() { window.removeEventListener('click', handleUserGestureToStartAudio); window.removeEventListener('keydown', handleUserGestureToStartAudio); initializeAudioContextNonBlocking(); }

// Configure les lecteurs audio pour les sons de l'application
function setupAudioPlayers() {
    trophySoundPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination();
    levelUpPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.1, release: 0.2 } }).toDestination();
    majorLevelUpPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.6 }, volume: -6 }).toDestination();
    beepPlayer = new Tone.Oscillator(440, "sine").toDestination();
    startSoundPlayer = new Tone.PolySynth(Tone.Synth).toDestination();
    synth = window.speechSynthesis;
    Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
    Tone.Master.mute = !isAudioActive;
}

// Active ou désactive le son de l'application
function toggleAudioActive() {
    isAudioActive = !isAudioActive;
    if (isAudioActive) { initializeAudioContextNonBlocking(); showMessage("SON ACTIVÉ !", "success"); }
    else { Tone.Master.mute = true; showMessage("SON DÉSACTIVÉ.", "info"); }
    const mainContent = document.getElementById('main-content');
    renderOptionsView(mainContent);
}

// Joue le son de trophée
function playTrophySound() { if (isAudioActive &amp;&amp; Tone.context.state === 'running') trophySoundPlayer.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n", Tone.context.currentTime); }

// Joue le son de montée de niveau
function playLevelUpSound(level) {
    if (isAudioActive &amp;&amp; Tone.context.state === 'running') {
        const now = Tone.context.currentTime;
        if (level &gt; previousLevel) {
            if (level % 10 === 0) majorLevelUpPlayer.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5"], "2n", now);
            else { levelUpPlayer.triggerAttackRelease("C4", "16n", now); levelUpPlayer.triggerAttackRelease("E4", "16n", now + 0.1); levelUpPlayer.triggerAttackRelease("G4", "16n", now + 0.2); levelUpPlayer.triggerAttackRelease("C5", "8n", now + 0.3); }
        }
    }
}

// Joue un bip sonore
function playBeep(freq = 4, duration = 0.0) { if (isAudioActive &amp;&amp; Tone.context.state === 'running') { beepPlayer.stop(); beepPlayer.start(Tone.context.currentTime); beepPlayer.frequency.setValueAtTime(freq, Tone.context.currentTime); beepPlayer.stop(Tone.context.currentTime + duration); } }

// Joue un son de démarrage (type Mario Kart)
function playMarioKartStartSound() {
    if (isAudioActive &amp;&amp; Tone.context.state === 'running') {
        const now = Tone.context.currentTime;
        new Tone.MembraneSynth().toDestination().triggerAttackRelease("C5", "16n", now);
        new Tone.MembraneSynth().toDestination().triggerAttackRelease("E5", "16n", now);
        new Tone.MembraneSynth().toDestination().triggerAttackRelease("G5", "16n", now);
        new Tone.Synth().toDestination().triggerAttackRelease("C4", "1n", now );
    }
}

// Fonction pour parler avec Kodular (intégration)
function parlerAvecKodular(texte) {
    if (window.AppInventor &amp;&amp; window.AppInventor.setWebViewString) {
        window.AppInventor.setWebViewString(texte);
    } else {
        console.log("KODULAR NON DÉTECTÉ, TEXTE À PRONONCER : " + texte);
    }
}

// Fait parler l'IA avec la synthèse vocale
function speak(text) {
    if (!isAudioActive) return; // Ne parle que si l'audio est actif

    // Priorise l'intégration Kodular si disponible
    if (window.AppInventor &amp;&amp; window.AppInventor.setWebViewString) {
        parlerAvecKodular(text);
    } else if (synth) { // Repli sur la synthèse vocale du navigateur si pas dans Kodular
        synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'fr-FR';
        synth.speak(utterance);
    }
}

// Génère un identifiant unique
function generateUniqueId() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c =&gt; { const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r &amp; 0x3 | 0x8); return v.toString(16); }); }

// Formate une date au formatYYYY-MM-DD
function formatDateToYYYYMMDD(date) { if (!(date instanceof Date) || isNaN(date.getTime())) return ''; const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }

// Retourne une chaîne de caractères décrivant le contexte du jour (poste et sport)
function getDayContextString(shiftType, workoutType) {
    let context = "";
    const sType = String(shiftType || ''), wType = String(workoutType || '');
    switch (sType) {
        case '6h-18h': context = "Travail de Jour (6H-18H)"; break;
        case '7h-18h': context = "Travail de Jour (7H-18H)"; break;
        case '18h-6h': context = "Travail de Nuit (18H-6H)"; break;
        case 'repos': context = "Jour de Repos"; break;
        case 'repos_sport': context = "Jour de Repos (SPORT)"; break;
        default: context = "Contexte Inconnu"; break;
    }
    if (wType &amp;&amp; wType !== 'aucun') context += ` - Sport: ${wType.toUpperCase().replace('_', ' ')}`;
    return context;
}

// Retourne une chaîne de caractères décrivant le moment du repas dans le contexte du jour
function getMealMomentContext(mealType, shiftType, sportType) {
    let moment = "";
    const sType = String(shiftType || ''), spType = String(sportType || '');
    if (mealType === 'petit_dejeuner') { moment = "PETIT-DÉJEUNER"; if (sType === '18h-6h') moment += " POST-NUIT"; else if (spType !== 'aucun') moment += " PRÉ-ENTRAÎNEMENT"; }
    else if (mealType === 'dejeuner') { moment = "DÉJEUNER"; if (sType === '18h-6h') moment += " PENDANT LE POSTE DE NUIT"; else if (spType !== 'aucun') moment += " POST-ENTRAÎNEMENT"; else if (sType.includes('jour')) moment += " JOURNÉE DE TRAVAIL"; }
    else if (mealType === 'diner') { moment = "DÎNER"; if (sType === '18h-6h') moment = "PRÉ-POSTE DE NUIT"; else if (spType !== 'aucun') moment += " POST-ENTRAÎNEMENT"; else if (sType.includes('jour')) moment += " APRÈS JOURNÉE DE TRAVAIL"; }
    else if (mealType === 'collation_matin') { moment = "COLLAT. MATIN"; }
    else if (mealType === 'collation_apresmidi') { moment = "COLLAT. APRÈS-MIDI"; }
    else if (mealType === 'collation_unique') { if (sType === '18h-6h') moment = "COLLAT. PENDANT POSTE DE NUIT"; else { /* addMeal = false; */ } } // This `addMeal` here is a local variable, not global. It should be handled by the caller.
    return moment;
}

// Conseils spécifiques pour les repas en fonction du contexte
const specificMealAdvice = {
    'petit_dejeuner': { '18h-6h': "CONSEIL : APRÈS UN POSTE DE NUIT, PRIVILÉGIE UN REPAS NUTRITIF POUR FAVORISER LA RÉCUPÉRATION ET UN SOMMEIL DE QUALITÉ. LES PROTÉINES ET GLUCIDES LENTS SONT CLÉS.", 'default': "CONSEIL : UN PETIT-DÉJEUNER ÉQUILIBRÉ EST ESSENTIEL POUR L'ÉNERGIE DU MATIN. VARIE LES SOURCES DE PROTÉINES ET FIBRES." },
    'dejeuner': { '18h-6h': "CONSEIL : PENDANT UN POSTE DE NUIT, OPTE POUR DES PLATS FACILES À DIGÉRER, RICHES EN PROTÉINES ET LÉGUMES POUR MAINTENIR TON ÉNERGIE SANS ALOURDIR.", 'repos_sport': "CONSEIL : APRÈS LE SPORT, RECONSTITUE TES RÉSERVES. CE REPAS DEVRAIT ÊTRE RICHE EN GLUCIDES COMPLEXES POUR L'ÉNERGIE ET LA RÉPARATION MUSCULAIRE.", 'default': "CONSEIL : POUR UN DÉJEUNER OPTIMAL EN JOURNÉE DE TRAVAIL, PRIVILÉGIE UN PLAT ÉQUILIBRÉ QUI APPORTE UNE ÉNERGIE DURABLE SANS CAUSER DE COUP DE BARRE." },
    'diner': { '18h-6h': "CONSEIL : AVANT UN POSTE DE NUIT, CHOISIS UN DÎNER CONSISTANT MAIS FACILE À DIGÉRER POUR TE DONNER L'ENERGIE NÉCESSAIRE SANS PERTURBER TON DÉBUT DE SOMMEIL PRÉ-POSTE.", 'repos_sport': "CONSEIL : LE DÎNER APRÈS UNE SÉANCE DE SPORT DOIT COMPLÉTER LA RÉCUPÉRATION. CONCENTRE-TOI SUR LES PROTÉINES POUR LA RÉPARATION ET LES GLUCIDES POUR REFAIRE LE PLEIN.", 'default': "CONSEIL : UN DÎNER LÉGER EST IDÉAL POUR FAVORISER UNE BONNE DIGESTION ET UN SOMMEIL RÉPARATEUR APRÈS UNE JOURNÉE DE TRAVAIL. PRIVILÉGIE LES LÉGUMES ET PROTÉINES MAIGRES." },
    'collation': { '6h-18h_matin': "CONSEIL : CETTE COLLATON MATINALE EST CLÉ POUR MAINTENIR TON ÉNERGIE ET ÉVITER LES BAISSES DE GLYCÉMIE JUSQU'AU DÉJEUNER.", '6h-18h_apresmidi': "CONSEIL : LA COLLATON DE L'APRÈS-MIDI AIDE À GÉRER LA FAIM ET À SOUTENIR TON ÉNERGIE JUSQU'AU DÎNER, SANS ALOURDIR AVANT LA FIN DU POSTE.", '18h-6h_pendant': "CONSEIL : UNE COLLATON PENDANT LA NUIT EST LÉGÈRE ET ÉNERGISANTE POUR MAINTENIR TA VIGILANCE SANS PERTURBER TA DIGESTION.", '7h-18h_apresmidi': "CONSEIL : LA COLLATON DE L'APRÈS-MIDI EST PARFAITE POUR SOUTENIR SON ÉNERGIE LORS DES JOURS DE LONG POSTE OU DE REPOS ACTIF.", 'repos_sport_post': "CONSEIL : UNE COLLATON POST-SPORT EST CRUCIALE POUR UNE RÉCUPÉRATION RAPIDE. PRIVILÉGIE UN MIX DE PROTÉINES ET GLUCIDES.", 'repos_default': "CONSEIL : UNE COLLATON LÉGÈRE EN JOUR DE REPOS PEUT AIDER À GÉRER LA FAIM ET APPORTER DES NUTRIENTS SUPPLÉMENTAIRES." }
};

// Calcule les seuils d'XP pour chaque niveau
function getLevelThresholds(level) {
    if (level === 0) return { current: 0, next: 100 };
    let xp = 0;
    for (let i = 1; i &lt;= level; i++) xp += (i * 50 + 50);
    const prevLevelThreshold = xp - (level * 50 + 50);
    return { current: prevLevelThreshold, next: xp };
}

// Calcule le niveau actuel et l'XP restante pour le niveau suivant
function calculateLevelAndXP(totalXP) {
    let level = 0;
    let xpNeededForCurrentLevel = 0;
    let xpNeededForNextLevel = 100;

    while (totalXP &gt;= xpNeededForNextLevel) {
        level++;
        xpNeededForCurrentLevel = xpNeededForNextLevel;
        xpNeededForNextLevel = Math.round(100 + (level * 50 * (1 + level / 10)));
    }// Fonction pour rendre les icônes Lucide

    const xpProgressInCurrentLevel = totalXP - xpNeededForCurrentLevel;
    const xpForThisLevel = xpNeededForNextLevel - xpNeededForCurrentLevel;
    const xpRemainingForNextLevel = xpForThisLevel - xpProgressInCurrentLevel;

    return { level: level, xpCurrentLevel: xpProgressInCurrentLevel, xpForThisLevel: xpForThisLevel, xpToNextLevel: xpRemainingForNextLevel };
}

// Initialise l'application au démarrage
async function initializeApp() {
    setupAudioPlayers();
    initializeGlobalState();
    updateXPBar();
    updateProfileDisplay();
    userId = 'local_user';
    document.getElementById('user-id-value').textContent = userId;
    document.getElementById('user-id-display').classList.remove('hidden');
    renderPage(currentPage);
    attachEventListeners();
    renderLucideIcons();
    window.addEventListener('click', handleUserGestureToStartAudio, { once: true });
    window.addEventListener('keydown', handleUserGestureToStartAudio, { once: true });
    initializeAudioContextNonBlocking();
}

// Rend la page principale en fonction du nom de la page
function renderPage(pageName) {
    const mainContent = document.getElementById('main-content');
    mainContent.innerHTML = '';
    if (weightChartInstance) { weightChartInstance.destroy(); weightChartInstance = null; }
    if (exerciseChartInstance) { exerciseChartInstance = null; } // Changed to null, not destroy, as it might be recreated

    document.querySelectorAll('.nav-item').forEach(button =&gt; {
        const isActive = button.dataset.page === pageName;
        button.classList.toggle('bg-blue-600', isActive);
        button.classList.toggle('text-white', isActive);
        button.classList.toggle('font-semibold', isActive);
        button.classList.toggle('border-blue-800', isActive);
        button.classList.toggle('shadow-inner', isActive);
        button.classList.toggle('text-gray-200', !isActive);
        button.classList.toggle('hover:bg-gray-700', !isActive);
        button.classList.toggle('hover:text-yellow-300', !isActive);
        button.classList.toggle('border-gray-700', !isActive);
    });

    currentPage = pageName;

    switch (pageName) {
        case 'daily_plan': renderDailyPlanView(mainContent); break;
        case 'workout': renderWorkoutView(mainContent); break;
        case 'recipes': renderRecipeView(mainContent); break;
        case 'chrono': renderChronoIntervalleView(mainContent); break;
       case 'progress': renderProgressView(mainContent); break;
        case 'trophies': renderTrophyRoomView(mainContent); break;
        case 'calendar': renderCalendarView(mainContent); break; // Nouvelle ligne
        case 'options': renderOptionsView(mainContent); break;
        default: renderDailyPlanView(mainContent); break;
    }
    renderLucideIcons();
}

// Met à jour la barre d'expérience (XP) et le niveau de l'utilisateur
function updateXPBar() {
    const { level, xpCurrentLevel, xpForThisLevel } = calculateLevelAndXP(userProfile.currentXP);
    const progressBar = document.getElementById('xp-bar-fill');
    const progressText = document.getElementById('xp-bar-text');

    const progressPercentage = xpForThisLevel &gt; 0 ? (xpCurrentLevel / xpForThisLevel) * 100 : 0;
    const actualProgress = Math.max(0, Math.min(100, progressPercentage));

    if (level &gt; previousLevel) {
        playLevelUpSound(level);
        showMessage(`FÉLICITATIONS, VOUS AVEZ ATTEINT LE NIVEAU ${level} !`, 'success');
        speak(`Felicitations, vous avez atteint le niveau ${level} !`);
        progressBar.style.transition = 'none';
        progressBar.style.width = '0%';
        void progressBar.offsetWidth; // Trigger reflow
        setTimeout(() =&gt; { progressBar.style.transition = 'width 0.5s ease-in-out, background 0.5s ease-in-out'; progressBar.style.width = `${actualProgress}%`; }, 150);
    } else {
        progressBar.style.transition = 'width 0.5s ease-in-out, background 0.5s ease-in-out';
        progressBar.style.width = `${actualProgress}%`;
    }
    progressText.textContent = `LVL ${level} : ${xpCurrentLevel}/${xpForThisLevel} XP`;
    previousLevel = level;
    checkAndAwardTrophies(level);
}

// Vérifie si des trophées ont été gagnés et les attribue
function checkAndAwardTrophies(currentLevel) {
    let earnedTrophies = userProfile.earnedTrophies || [], newTrophiesEarned = [];
    allTrophies.forEach(trophy =&gt; {
        if (currentLevel &gt;= trophy.levelRequired &amp;&amp; !earnedTrophies.some(t =&gt; t.id === trophy.id)) {
            newTrophiesEarned.push(trophy);
            earnedTrophies.push({ id: trophy.id, name: trophy.name, description: trophy.description, levelRequired: trophy.levelRequired, timestamp: new Date().toISOString() });
        }
    });
    if (newTrophiesEarned.length &gt; 0) {
        userProfile.earnedTrophies = earnedTrophies;
        saveToLocalStorage('userProfile', userProfile);
        newTrophiesEarned.forEach(trophy =&gt; showTrophyNotification(trophy.name, trophy.description));
        if (currentPage === 'trophies') renderTrophyRoomView(document.getElementById('main-content'));
    }
}

// Met à jour l'affichage du profil utilisateur
function updateProfileDisplay() {
    const heightInput = document.getElementById('userHeight');
    const weightInput = document.getElementById('userWeight');
    const imcDisplay = document.getElementById('imc-display');
    const imcValue = document.getElementById('imc-value');
    const imcCategory = document.getElementById('imc-category');
    const proteinNeeds = document.getElementById('protein-needs');

    heightInput.value = userProfile.height;
    weightInput.value = userProfile.weight;

    if (userProfile.imc &amp;&amp; userProfile.imcCategory &amp;&amp; userProfile.proteinNeeds) {
        imcValue.textContent = userProfile.imc;
        imcCategory.textContent = userProfile.imcCategory;
        proteinNeeds.textContent = `${userProfile.proteinNeeds} G/JOUR`;
        imcDisplay.classList.remove('hidden');
    } else {
        imcDisplay.classList.add('hidden');
    }
}

// Gère la sauvegarde du profil utilisateur (taille, poids, IMC)
async function handleSaveProfile() {
    const height = document.getElementById('userHeight').value;
    const weight = document.getElementById('userWeight').value;

    if (!height || !weight) { showMessage("ERREUR: TAILLE ET POIDS REQUIS POUR L'IMC.", 'error'); return; }

    const currentHeight = parseFloat(height);
    const currentWeight = parseFloat(weight);
    const currentImc = (currentWeight / ( (currentHeight / 100) * (currentHeight / 100) )).toFixed(2);

    let currentImcCategory;
    const imcVal = parseFloat(currentImc);
    const imcCategories = [
        { threshold: 16.5, category: 'INSUFFISANCE PONDÉRALE (DÉNUTRITION SÉVÈRE)' },
        { threshold: 18.5, category: 'INSUFFISANCE PONDÉRALE' },
        { threshold: 25, category: 'POIDS NORMAL' },
        { threshold: 27, category: 'SURPOIDS (PRÉ-OBÉSITÉ)' },
        { threshold: 30, category: 'OBÉSITÉ MODÉRÉE' },
        { threshold: 35, category: 'OBÉSITÉ CLASSE I' },
        { threshold: 40, category: 'OBÉSITÉ CLASSE II (SÉVÈRE)' },
        { threshold: Infinity, category: 'OBÉSITÉ CLASSE III (MORBIDE OU MASSIVE)' }
    ];
    for (const cat of imcCategories) { if (imcVal &lt; cat.threshold) { currentImcCategory = cat.category; break; } }

    const proteinMultiplier = 1.6;
    const currentProteinNeeds = (currentWeight * proteinMultiplier).toFixed(0);

    let newXP = userProfile.currentXP;
    const oldWeight = parseFloat(userProfile.weight) || 0;
    const oldImcCategory = userProfile.imcCategory || '';

    if (oldWeight &gt; 0 &amp;&amp; currentWeight !== oldWeight) {
        const weightDiff = oldWeight - currentWeight;
        const oldImcIndex = imcCategories.findIndex(c =&gt; c.category === oldImcCategory);
        const currentImcIndex = imcCategories.findIndex(c =&gt; c.category === currentImcCategory);

        if (currentImcIndex &lt; oldImcIndex) { newXP += 50; showMessage(`XP GAGNÉE: AMÉLIORATION DE L'IMC !`, 'success'); }
        else if (currentImcIndex &gt; oldImcIndex) { newXP = Math.max(0, newXP - 30); showMessage(`XP PERDUE: DÉTÉRIORATION DE L'IMC.`, 'warning'); }

        if (currentImcCategory === 'POIDS NORMAL') {
            if (!oldImcCategory.includes('POIDS NORMAL')) { newXP += 100; showMessage(`XP GAGNÉE: ENTRÉE DANS LA CATÉGORIE DE POIDS NORMAL !`, 'success'); }
            else { newXP += 5; showMessage(`XP GAGNÉE: MAINTIEN DANS LA CATÉGORIE DE POIDS NORMAL !`, 'success'); }
        } else if (currentImcCategory.includes('INSUFFISANCE PONDÉRALE') &amp;&amp; weightDiff &lt; 0) { newXP += Math.round(Math.abs(weightDiff) * 10); showMessage(`XP GAGNÉE: PRISE DE POIDS VERS LA NORMALITÉ !`, 'success'); }
        else if ((currentImcCategory.includes('SURPOIDS') || currentImcCategory.includes('OBÉSITÉ')) &amp;&amp; weightDiff &gt; 0) { newXP += Math.round(weightDiff * 10); showMessage(`XP GAGNÉE: PERTE DE POIDS VERS LA NORMALITÉ !`, 'success'); }
        else if (currentImcCategory.includes('INSUFFISANCE PONDÉRALE') &amp;&amp; weightDiff &gt; 0) { newXP = Math.max(0, newXP - Math.round(Math.abs(weightDiff) * 5)); showMessage(`XP PERDUE: PERTE DE POIDS À PARTIR DE LA NORMALITÉ !`, 'warning'); }
        else if ((currentImcCategory.includes('SURPOIDS') || currentImcCategory.includes('OBÉSITÉ')) &amp;&amp; weightDiff &lt; 0) { newXP = Math.max(0, newXP - Math.round(Math.abs(weightDiff) * 5)); showMessage(`XP PERDUE: PRISE DE POIDS À PARTIR DE LA NORMALITÉ !`, 'warning'); }
    }

    userProfile = { ...userProfile, height: currentHeight, weight: currentWeight, imc: currentImc, imcCategory: currentImcCategory, proteinNeeds: currentProteinNeeds, currentXP: newXP, updatedAt: new Date().toISOString() };
    saveToLocalStorage('userProfile', userProfile);
    updateProfileDisplay();
    updateXPBar();

    const today = new Date();
    today.setHours(0, 0, 0, 0); // Normalize to start of day
    const todayFormatted = formatDateToYYYYMMDD(today);

    const existingEntryIndex = weightHistory.findIndex(entry =&gt; formatDateToYYYYMMDD(new Date(entry.date)) === todayFormatted);

    if (existingEntryIndex !== -1) {
        // Update existing entry for today
        weightHistory[existingEntryIndex] = {
            ...weightHistory[existingEntryIndex],
            weight: currentWeight,
            imc: currentImc,
            imcCategory: currentImcCategory,
            timestamp: new Date().toISOString()
        };
    } else {
        // Add new entry
        weightHistory.push({
            id: generateUniqueId(),
            date: new Date().toISOString(),
            weight: currentWeight,
            imc: currentImc,
            imcCategory: currentImcCategory,
            timestamp: new Date().toISOString()
        });
    }
    saveToLocalStorage('weightHistory', weightHistory);

    if (currentPage === 'progress') renderProgressView(document.getElementById('main-content'));
}

// Rend la vue du planning quotidien
function renderDailyPlanView(container) {
    let html = `&lt;div class="card-retro mb-6"&gt;&lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;MON PLANNING&lt;/h2&gt;&lt;div class="mb-6 space-y-4 p-4 rounded-lg border-2 border-blue-700 bg-gray-700"&gt;&lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;AJOUTER UN POSTE :&lt;/h3&gt;&lt;div class="relative"&gt;&lt;label for="shiftDate" class="block text-white-200 text-sm font-bold mb-2"&gt;DATE DU POSTE :&lt;/label&gt;&lt;input type="date" id="shiftDate" class="input-retro pr-10" style="color: #ffffff;" value="" /&gt;&lt;i data-lucide="calendar" class="absolute right-11 top-12 -translate-y-1/2 text-white pointer-events-none" style="width:15px; height:18px;"&gt;&lt;/i&gt;&lt;/div&gt;&lt;div&gt;&lt;label for="shiftType" class="block text-gray-200 text-sm font-bold mb-2"&gt;TYPE DE POSTE :&lt;/label&gt;&lt;select id="shiftType" class="select-retro"&gt;&lt;option value="6h-18h"&gt;POSTE JOUR (6H-18H)&lt;/option&gt;&lt;option value="7h-18h"&gt;POSTE JOUR (7H-18H)&lt;/option&gt;&lt;option value="18h-6h"&gt;POSTE NUIT (18H-6H)&lt;/option&gt;&lt;option value="repos"&gt;JOUR DE REPOS&lt;/option&gt;&lt;option value="repos_sport"&gt;JOUR DE REPOS (SPORT)&lt;/option&gt;&lt;/select&gt;&lt;/div&gt;&lt;div&gt;&lt;label for="workoutType" class="block text-gray-200 text-sm font-bold mb-2"&gt;SÉANCE SPORT PRÉVUE :&lt;/label&gt;&lt;select id="workoutType" class="select-retro"&gt;&lt;option value="aucun"&gt;AUCUNE&lt;/option&gt;&lt;option value="renforcement"&gt;RENFORCEMENT MUSCULAIRE&lt;/option&gt;&lt;option value="cardio"&gt;CARDIO&lt;/option&gt;&lt;option value="hiit"&gt;HIIT&lt;/option&gt;&lt;option value="repos_actif"&gt;RÉCUPÉRATION ACTIVE / FLEXIBILITÉ&lt;/option&gt;&lt;/select&gt;&lt;/div&gt;&lt;button id="add-shift-btn" class="btn-retro w-full"&gt;AJOUTER POSTE&lt;/button&gt;&lt;/div&gt;&lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;TON PLAN POUR LES JOURS PLANIFIÉS :&lt;/h3&gt;&lt;div id="shifts-list" class="space-y-6"&gt;&lt;/div&gt;&lt;/div&gt;`;
    container.innerHTML = html;

    const shiftDateInput = document.getElementById('shiftDate');
    const shiftTypeSelect = document.getElementById('shiftType');
    const workoutTypeSelect = document.getElementById('workoutType');
    const addShiftBtn = document.getElementById('add-shift-btn');
    const shiftsListDiv = document.getElementById('shifts-list');

    addShiftBtn.onclick = async () =&gt; {
        const date = shiftDateInput.value;
        const type = shiftTypeSelect.value;
        const workout = workoutTypeSelect.value;

        if (!date || !type) { showMessage("ERREUR: DATE ET TYPE DE POSTE REQUIS.", 'error'); return; }

        const dateObj = new Date(date);
        dateObj.setHours(0, 0, 0, 0); // Normalize to start of day

        if (shifts.some(s =&gt; formatDateToYYYYMMDD(new Date(s.date)) === formatDateToYYYYMMDD(dateObj))) { showMessage("ERREUR: POSTE DÉJÀ ENREGISTRÉ POUR CETTE DATE.", 'error'); return; }

        shifts.push({ id: generateUniqueId(), date: dateObj.toISOString(), type: type, workoutType: workout, createdAt: new Date().toISOString() });
        saveToLocalStorage('shifts', shifts);
        showMessage("SUCCÈS: POSTE AJOUTÉ !", 'success');

        shiftDateInput.value = '';
        workoutTypeSelect.value = 'aucun';
        renderDailyPlanView(container);
    };

    renderShiftsList(shiftsListDiv, shifts);
}

// Rend la liste des postes planifiés
function renderShiftsList(container, shiftsData) {
    container.innerHTML = '';
    if (shiftsData.length === 0) { container.innerHTML = '&lt;p class="text-gray-400"&gt;AUCUN POSTE ENREGISTRÉ. AJOUTE TON PREMIER POSTE CI-DESSOUS !&lt;/p&gt;'; return; }

    const sortedShifts = [...shiftsData].sort((a, b) =&gt; new Date(b.date).getTime() - new Date(a.date).getTime());

    sortedShifts.forEach(shift =&gt; {
        const dateObj = new Date(shift.date);
        const dateString = dateObj.toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }).toUpperCase();
        const routine = sleepRoutines[String(shift.type)] || sleepRoutines['repos'];
        const mealForThisDay = weeklyMealPlan?.semaine?.find(d =&gt; d.date === formatDateToYYYYMMDD(dateObj));

        const shiftDiv = document.createElement('div');
        shiftDiv.className = "bg-gray-700 p-4 rounded-lg border-4 border-purple-500 shadow-lg";
        shiftDiv.innerHTML = `
            &lt;div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3"&gt;
                &lt;h4 class="text-lg sm:text-xl font-bold text-yellow-300"&gt;${dateString} - POSTE: ${String(shift.type).toUpperCase()}&lt;/h4&gt;
                &lt;button class="btn-retro-red text-sm px-3 py-1 mt-2 sm:mt-0 delete-shift-btn" data-id="${shift.id}" data-date="${formatDateToYYYYMMDD(dateObj)}"&gt;SUPPRIMER&lt;/button&gt;
            &lt;/div&gt;
            ${String(shift.workoutType) !== 'aucun' ? `&lt;div class="mb-3 p-2 bg-blue-800 rounded-md border border-purple-400"&gt;&lt;p class="text-sm sm:text-base font-medium text-white"&gt;SÉANCE SPORT : ${String(shift.workoutType).toUpperCase().replace('_', ' ')} PRÉVUE&lt;/p&gt;&lt;/div&gt;` : ''}
            &lt;div class="mb-4"&gt;
                &lt;h5 class="font-semibold text-base sm:text-lg text-yellow-300 mb-2"&gt;💤 ROUTINE SOMMEIL : ${String(routine.name).toUpperCase()}&lt;/h5&gt;
                &lt;ul class="list-disc list-inside text-gray-300 text-sm space-y-1"&gt;
                    ${routine.details.map(detail =&gt; `&lt;li&gt;${String(detail).toUpperCase()}&lt;/li&gt;`).join('')}
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div class="mb-4"&gt;
                &lt;h5 class="font-semibold text-base sm:text-lg text-yellow-300 mb-2"&gt;🍽️ PLAN REPAS SUGGÉRÉ :&lt;/h5&gt;
                ${mealForThisDay ? `
                    &lt;ul class="list-disc list-inside text-gray-300 text-sm space-y-1"&gt;
                        ${mealForThisDay.petit_dejeuner ? `&lt;li&gt;**PETIT-DÉJEUNER :** ${String(mealForThisDay.petit_dejeuner.title || 'TITRE INDISPONIBLE').toUpperCase()}&lt;/li&gt;` : ''}
                        ${mealForThisDay.dejeuner ? `&lt;li&gt;**DÉJEUNER :** ${String(mealForThisDay.dejeuner.title || 'TITRE INDISPONIBLE').toUpperCase()}&lt;/li&gt;` : ''}
                        ${mealForThisDay.diner ? `&lt;li&gt;**DÎNER :** ${String(mealForThisDay.diner.title || 'TITRE INDISPONIBLE').toUpperCase()}&lt;/li&gt;` : ''}
                        ${mealForThisDay.collation_matin ? `&lt;li&gt;**COLLAT. MATIN :** ${String(mealForThisDay.collation_matin.title || 'TITRE INDISPONIBLE').toUpperCase()}&lt;/li&gt;` : ''}
                        ${mealForThisDay.collation_apresmidi ? `&lt;li&gt;**COLLAT. APRÈS-MIDI :** ${String(mealForThisDay.collation_apresmidi.title || 'TITRE INDISPONIBLE').toUpperCase()}&lt;/li&gt;` : ''}
                        ${mealForThisDay.collation_unique ? `&lt;li&gt;**COLLAT. UNIQUE :** ${String(mealForThisDay.collation_unique.title || 'TITRE INDISPONIBLE').toUpperCase()}&lt;/li&gt;` : ''}
                    &lt;/ul&gt;
                ` : `&lt;p class="text-gray-400"&gt;PLAN DE REPAS NON DISPONIBLE POUR CE JOUR. GÉNÉREZ UN PLAN HEBDOMADAIRE DANS L'ONGLET "RECETTES".&lt;/p&gt;`}
            &lt;/div&gt;
        `;
        container.appendChild(shiftDiv);
    });

    container.querySelectorAll('.delete-shift-btn').forEach(button =&gt; {
        button.onclick = async (event) =&gt; {
            const idToDelete = event.target.dataset.id;
            const dateToDelete = event.target.dataset.date;
            if (await showConfirmModal("CONFIRMER LA SUPPRESSION DU POSTE ET DE SON PLAN DE REPAS ASSOCIÉ ?")) {
                shifts = shifts.filter(s =&gt; s.id !== idToDelete);
                saveToLocalStorage('shifts', shifts);
                if (weeklyMealPlan &amp;&amp; weeklyMealPlan.semaine) {
                    weeklyMealPlan.semaine = weeklyMealPlan.semaine.filter(dayData =&gt; dayData.date !== dateToDelete);
                    saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                }
                showMessage("SUCCÈS: POSTE ET REPAS ASSOCIÉS SUPPRIMÉS !", 'success');
                renderDailyPlanView(document.getElementById('main-content'));
            }
        };
    });
}

// Rend la vue du programme sportif
function renderWorkoutView(container) {
    let html = `&lt;div class="card-retro mb-6"&gt;&lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;PROGRAMME SPORTIF&lt;/h2&gt;&lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700"&gt;&lt;h3 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300"&gt;LIGNES DIRECTRICES SPORTIVES :&lt;/h3&gt;&lt;ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"&gt;&lt;li&gt;ÉCOUTE TON CORPS : AVEC LA SCLÉROSE EN PLAQUES ET TES HORAIRES DE TRAVAIL, LA FATIGUE PEUT VARIER. SI TU TE SENS MOINS EN FORME, RÉDUIS L'INTENSITÉ, LE NOMBRE DE SÉRIES, OU OPTE POUR UNE SÉANCE PLUS LÉGÈRE OU DU REPOS ACTIF. NE FORCE JAMAIS LA DOULEUR.&lt;/li&gt;&lt;li&gt;LA FORME AVANT LA CHARGE : CONCENTRE-TOI SUR L'EXÉCUTION CORRECTE DE CHAQUE MOUVEMENT POUR MAXIMISER L'EFFICACITÉ ET PRÉVENIR LES BLESSURES. UNE BONNE TECHNIQUE EST PLUS IMPORTANTE QUE DE SOULEVER LOURD.&lt;/li&gt;&lt;li&gt;PROGRESSION PROGRESSIVE : L'OBJECTIF EST D'AMÉLIORER TES PERFORMANCES AU FIL DES SEMAINES. LORSQUE TU PEUX RÉALISER FACILEMENT LE MAXIMUM DE RÉPÉTITIONS/SÉRIES AVEC UNE BONNE FORME, AUGMENTE LÉGÈREMENT LA CHARGE (PAR PALIERS DE 2KG POUR LES HALTÈRES, OU 2.5KG/5KG POUR LES MACHINES) OU LE NOMBRE DE RÉPÉTITIONS.&lt;/li&gt;&lt;li&gt;HYDRATATION : BOIS DE L'EAU RÉGULIÈREMENT AVANT, PENDANT ET APRÈS CHAQUE SÉANCE.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class="mb-6 mt-6"&gt;&lt;label for="phaseSelect" class="block text-gray-200 text-sm font-bold mb-2"&gt;CHOISIR UNE PHASE :&lt;/label&gt;&lt;select id="phaseSelect" class="select-retro"&gt;&lt;option value="phase1"&gt;${String(workoutProgram.phase1?.name || 'PHASE 1').toUpperCase()}&lt;/option&gt;&lt;option value="phase2"&gt;${String(workoutProgram.phase2?.name || 'PHASE 2').toUpperCase()}&lt;/option&gt;&lt;/select&gt;&lt;/div&gt;&lt;div id="workout-phase-content" class="space-y-6"&gt;&lt;/div&gt;&lt;/div&gt;`;
    container.innerHTML = html;

    const phaseSelect = document.getElementById('phaseSelect');
    const workoutPhaseContent = document.getElementById('workout-phase-content');

    let selectedPhase = loadFromLocalStorage('selectedWorkoutPhase', 'phase1');
    if (!workoutProgram[selectedPhase]) selectedPhase = 'phase1'; // Fallback if saved phase is invalid
    saveToLocalStorage('selectedWorkoutPhase', selectedPhase); // Save validated phase

    phaseSelect.value = selectedPhase;

    function renderPhaseContent(phase) {
        const currentPhaseData = workoutProgram[phase];
        if (!currentPhaseData || !currentPhaseData.sessions || !currentPhaseData.sessions.main || !currentPhaseData.sessions.cardio || !currentPhaseData.sessions.hiit) {
            workoutPhaseContent.innerHTML = '&lt;p class="text-gray-400 text-center"&gt;CONTENU DE LA PHASE INDISPONIBLE. VEUILLEZ IMPORTER UN PROGRAMME VALIDE ET COMPLET.&lt;/p&gt;';
            return;
        }

        const generateExerciseHtml = (ex, index) =&gt; `
            &lt;div class="flex flex-col sm:flex-row sm:items-center justify-between p-3 rounded-md border-2 border-blue-700 bg-gray-800 shadow-md"&gt;
                &lt;div class="flex-1"&gt;
                    &lt;p class="font-medium text-gray-100 text-base sm:text-lg"&gt;${index + 1}. ${String(ex.name).toUpperCase()}&lt;/p&gt;
                    &lt;p class="text-sm text-gray-400 italic"&gt;${String(ex.desc).toUpperCase()}&lt;/p&gt;
                    ${ex.sets ? `&lt;p class="text-xs text-blue-300"&gt;SÉRIES/ROUNDS : ${String(ex.sets).toUpperCase()}&lt;/p&gt;` : ''}
                    ${ex.reps ? `&lt;p class="text-xs text-blue-300"&gt;RÉPÉTITIONS/DURÉE : ${String(ex.reps).toUpperCase()}&lt;/p&gt;` : ''}
                    ${ex.weight &amp;&amp; ex.weight !== 'N/A' ? `&lt;p class="text-xs text-blue-300"&gt;POIDS SUGGÉRÉ : ${String(ex.weight).toUpperCase()}&lt;/p&gt;` : ''}
                    ${ex.rest &amp;&amp; ex.rest !== 'N/A' ? `&lt;p class="text-xs text-yellow-300"&gt;TEMPS DE REPOS : ${String(ex.rest).toUpperCase()}&lt;/p&gt;` : ''}
                &lt;/div&gt;
                &lt;button class="btn-retro-green text-sm px-4 py-2 mt-2 sm:mt-0 log-workout-btn" data-exercise-name="${ex.name}" data-exercise-type="${ex.type}"&gt;ENREGISTRER&lt;/button&gt;
            &lt;/div&gt;
        `;

        let phaseHtml = `
            &lt;h3 class="text-xl sm:text-2xl font-bold text-blue-400"&gt;${String(currentPhaseData.name).toUpperCase()}&lt;/h3&gt;
            &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"&gt;
                &lt;h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300"&gt;ÉCHAUFFEMENT (10-15 MIN) :&lt;/h4&gt;
                &lt;ul class="list-disc list-inside text-gray-300 text-sm sm:text-base mb-4 space-y-1"&gt;
                    &lt;li&gt;**CARDIO LÉGER (5-7 MIN):** TAPIS (MARCHE RAPIDE 5.0 KM/H, PENTE 1.0) OU VÉLO/ELLIPTIQUE (NIVEAU 3-5).&lt;/li&gt;
                    &lt;li&gt;**MOBILISATIONS ARTICULAIRES DYNAMIQUES (5-8 MIN):** CERCLES DE BRAS, ROTATIONS DU TRONC, FENTES (SANS CHARGE), ROTATIONS DE HANCHES, CERCLES DE CHEVILLES ET DE POIGNETS (10-15 RÉPÉTITIONS DE CHAQUE).&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"&gt;
                &lt;h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300"&gt;${String(currentPhaseData.sessions.main.name).toUpperCase()}&lt;/h4&gt;
                &lt;h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400"&gt;CORPS DE SÉANCE (40-50 MINUTES) :&lt;/h5&gt;
                &lt;div class="space-y-3"&gt;
                    ${currentPhaseData.sessions.main.exercises.map(generateExerciseHtml).join('')}
                &lt;/div&gt;
                &lt;h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400"&gt;RÉCUPÉRATION (5-10 MIN) :&lt;/h5&gt;
                &lt;ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"&gt;
                    &lt;li&gt;**ÉTIREMENTS DOUX :** MAINTIENS CHAQUE ÉTIREMENT PENDANT 20-30 SECONDES, SANS DOULEUR. CONCENTRE-TOI SUR LES ISCHIO-JAMBIERS, QUADRICÈPES, PECTORAUX, DOS, ÉPAULES ET BRAS.&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"&gt;
                &lt;h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300"&gt;${String(currentPhaseData.sessions.cardio.name).toUpperCase()}&lt;/h4&gt;
                &lt;h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400"&gt;CORPS DE SÉANCE (35-45 MINUTES) :&lt;/h5&gt;
                &lt;div class="space-y-3"&gt;
                    ${currentPhaseData.sessions.cardio.options.map(generateExerciseHtml).join('')}
                &lt;/div&gt;
                &lt;h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400"&gt;RÉCUPÉRATION (5-10 MIN) :&lt;/h5&gt;
                &lt;ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"&gt;
                    &lt;li&gt;**ÉTIREMENTS DOUX :** MAINTIENS CHAQUE ÉTIREMENT PENDANT 20-30 SECONDES, SANS DOULEUR. CONCENTRE-TOI SUR LES ISCHIO-JAMBIERS, QUADRICÈPES, PECTORAUX, DOS, ÉPAULES ET BRAS.&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"&gt;
                &lt;h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300"&gt;${String(currentPhaseData.sessions.hiit.name).toUpperCase()}&lt;/h4&gt;
                &lt;p class="text-sm sm:text-base text-gray-300 mb-4"&gt;${String(currentPhaseData.sessions.hiit.desc).toUpperCase()}&lt;/p&gt;
                &lt;h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400"&gt;CORPS DE SÉANCE (20-25 MINUTES) :&lt;/h5&gt;
                &lt;div class="space-y-3"&gt;
                    ${currentPhaseData.sessions.hiit.exercises.map(generateExerciseHtml).join('')}
                &lt;/div&gt;
                &lt;h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400"&gt;RÉCUPÉRATION (5-10 MIN) :&lt;/h5&gt;
                &lt;ul class="list-disc list-inside text-gray-300 text-sm space-y-1"&gt;
                    &lt;li&gt;**RETOUR AU CALME :** MARCHE LÉGÈRE ET RESPIRATION PROFONDE.&lt;/li&gt;
                    &lt;li&gt;**ÉTIREMENTS DOUX :** AXÉS SUR LES MUSCLES PRINCIPAUX SOLLICITÉS.&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        `;

        if (workoutProgram.recovery) {
            phaseHtml += `
                &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"&gt;
                    &lt;h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300"&gt;${String(workoutProgram.recovery.name).toUpperCase()}&lt;/h4&gt;
                    &lt;p class="text-sm sm:text-base text-gray-300 mb-4"&gt;${String(workoutProgram.recovery.desc).toUpperCase()}&lt;/p&gt;
                    &lt;ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"&gt;
                        ${workoutProgram.recovery.activities.map(act =&gt; `&lt;li&gt;**${String(act.name).toUpperCase()} :** ${String(act.desc).toUpperCase()}&lt;/li&gt;`).join('')}
                    &lt;/ul&gt;
                &lt;/div&gt;
            `;
        }
        workoutPhaseContent.innerHTML = phaseHtml;
        renderLucideIcons(); // Ensure icons are rendered after content is added

        workoutPhaseContent.querySelectorAll('.log-workout-btn').forEach(button =&gt; {
            button.onclick = (event) =&gt; {
                const exerciseName = event.target.dataset.exerciseName;
                const exerciseType = event.target.dataset.exerciseType;
                showLogWorkoutModal({ name: exerciseName, type: exerciseType });
            };
        });
    }

    phaseSelect.onchange = (event) =&gt; {
        selectedPhase = event.target.value;
        saveToLocalStorage('selectedWorkoutPhase', selectedPhase);
        renderPhaseContent(selectedPhase);
    };

    renderPhaseContent(selectedPhase);
}

// Affiche la modale pour enregistrer un entraînement
function showLogWorkoutModal(currentExercise) {
    let modalHtml = `
        &lt;div id="log-workout-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 font-vt323"&gt;
            &lt;div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white"&gt;
                &lt;h3 class="text-2xl sm:text-3xl font-bold text-yellow-300 mb-4 text-center"&gt;ENREGISTRER L'ENTRAÎNEMENT&lt;/h3&gt;
                &lt;p class="text-lg sm:text-xl mb-4 text-center"&gt;${String(currentExercise?.name).toUpperCase()}&lt;/p&gt;
                &lt;div class="space-y-4"&gt;
                    &lt;div&gt;
                        &lt;label for="logSets" class="block text-gray-200 text-sm font-bold mb-2"&gt;SÉRIES / ROUNDS :&lt;/label&gt;
                        &lt;input type="text" id="logSets" class="input-retro" placeholder="EX: 3 ou 5 ROUNDS" /&gt;
                    &lt;/div&gt;
                    &lt;div&gt;
                        &lt;label for="logReps" class="block text-gray-200 text-sm font-bold mb-2"&gt;RÉPÉTITIONS / DURÉE :&lt;/label&gt;
                        &lt;input type="text" id="logReps" class="input-retro" placeholder="EX: 12 ou 30 MIN" /&gt;
                    &lt;/div&gt;
                    &lt;div&gt;
                        &lt;label for="logWeight" class="block text-gray-200 text-sm font-bold mb-2"&gt;POIDS (KG, LAISSER VIDE SI NON APPLICABLE) :&lt;/label&gt;
                        &lt;input type="number" id="logWeight" class="input-retro" placeholder="EX: 50" /&gt;
                    &lt;/div&gt;
                    &lt;div&gt;
                        &lt;label for="logFeeling" class="block text-gray-200 text-sm font-bold mb-2"&gt;RESSENTI :&lt;/label&gt;
                        &lt;select id="logFeeling" class="select-retro"&gt;
                            &lt;option value="facile"&gt;FACILE&lt;/option&gt;
                            &lt;option value="moyen"&gt;MOYEN&lt;/option&gt;
                            &lt;option value="difficile"&gt;DIFFICILE&lt;/option&gt;
                        &lt;/select&gt;
                    &lt;/div&gt;
                    &lt;div&gt;
                        &lt;label for="logNotes" class="block text-gray-200 text-sm font-bold mb-2"&gt;NOTES (OPTIONNEL) :&lt;/label&gt;
                        &lt;textarea id="logNotes" class="input-retro h-24" placeholder="Ajoutez des notes sur votre séance..."&gt;&lt;/textarea&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="flex justify-end space-x-4 mt-6"&gt;
                    &lt;button id="cancel-log-btn" class="btn-retro-red"&gt;ANNULER&lt;/button&gt;
                    &lt;button id="confirm-log-btn" class="btn-retro-green"&gt;ENREGISTRER&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `;
    document.getElementById('global-modals-container').innerHTML = modalHtml;
    const modal = document.getElementById('log-workout-modal');
    modal.querySelector('#cancel-log-btn').onclick = () =&gt; modal.remove();
    modal.querySelector('#confirm-log-btn').onclick = async () =&gt; {
        const sets = modal.querySelector('#logSets').value;
        const reps = modal.querySelector('#logReps').value;
        const weight = modal.querySelector('#logWeight').value;
        const feeling = modal.querySelector('#logFeeling').value;
        const notes = modal.querySelector('#logNotes').value;

        if (!sets || !reps) {
            showMessage("SÉRIES/ROUNDS ET RÉPÉTITIONS/DURÉE SONT REQUIS.", 'error');
            return;
        }

        const newLog = {
            id: generateUniqueId(),
            date: new Date().toISOString(),
            exerciseName: currentExercise.name,
            exerciseType: currentExercise.type,
            sets: sets,
            reps: reps,
            weight: weight ? parseFloat(weight) : null,
            feeling: feeling,
            notes: notes
        };
        workoutLogs.push(newLog);
        saveToLocalStorage('workoutLogs', workoutLogs);

        // Gagner de l'XP pour l'entraînement
        let xpGain = 20; // Base XP for logging a workout
        if (feeling === 'facile') xpGain += 10;
        else if (feeling === 'moyen') xpGain += 5;
        userProfile.currentXP += xpGain;
        saveToLocalStorage('userProfile', userProfile);
        updateXPBar();

        showMessage("ENTRAÎNEMENT ENREGISTRÉ ! XP GAGNÉE.", 'success');
        modal.remove();
        if (currentPage === 'progress') renderProgressView(document.getElementById('main-content'));

        // Generate AI advice
        await generateWorkoutAdvice(newLog);
    };
}

// Generate AI advice for workout
async function generateWorkoutAdvice(workoutLog) {
    const apiKey = userProfile.apiKey || "";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

    // Debugging API key and URL
    console.log(`[API KEY DEBUG] Using API Key: ${apiKey ? 'Provided (length: ' + apiKey.length + ')' : 'Empty (expecting Canvas injection)'}`);
    console.log(`[API KEY DEBUG] API URL: ${apiUrl}`);

    const userHeight = userProfile.height;
    const userWeight = userProfile.weight;
    const userImc = userProfile.imc;
    const userImcCategory = userProfile.imcCategory;
    const userProteinNeeds = userProfile.proteinNeeds;

    const prompt = `
    Génère un conseil personnalisé pour l'utilisateur suite à son entraînement.
    L'utilisateur est Gérard Chanot, pseudo Waeky, agent de sécurité avec une sclérose en plaques rémittente progressive bien gérée.
    Il a des postes de 11h-12h, répartis en 3 types (6h-18h, 18h-6h, 7h-18h), avec 12-15 postes par mois.
    Son profil actuel: Taille: ${userProfile.height}cm, Poids: ${userProfile.weight}kg, IMC: ${userProfile.imc} (${userProfile.imcCategory}), Besoins en protéines: ${userProfile.proteinNeeds}g/jour.

    Détails de l'entraînement enregistré:
    - Exercice: ${workoutLog.exerciseName} (Type: ${workoutLog.exerciseType})
    - Séries/Rounds: ${workoutLog.sets}
    - Répétitions/Durée: ${workoutLog.reps}
    - Poids utilisé: ${workoutLog.weight ? workoutLog.weight + ' KG' : 'N/A'}
    - Ressenti: ${workoutLog.feeling}
    - Notes de l'utilisateur: ${workoutLog.notes || 'Aucune'}

    En te basant sur ces informations et son profil (en particulier la SEP et les horaires de travail), donne un conseil concis et motivant.
    Le conseil doit être direct, sans fioritures ni introduction de conversation.
    Adapte le conseil au ressenti :
    - Si "facile": Suggère une légère augmentation de l'intensité ou du volume pour la prochaine fois, ou de varier l'exercice.
    - Si "moyen": Encourage la constance et la bonne forme, et de maintenir l'intensité.
    - Si "difficile": Rappelle l'importance de l'écoute du corps, du repos, de l'hydratation, et de ne pas hésiter à réduire l'intensité si la fatigue liée à la SEP est présente.
    - Mentionne brièvement son rôle d'agent de sécurité et la SEP si pertinent pour le conseil.

    Le conseil doit être court (max 2-3 phrases) et uniquement le texte du conseil, sans préambule ni salutations.
    `;

    const payload = {
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        generationConfig: {
            responseMimeType: "text/plain"
        }
    };

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Erreur HTTP: ${response.status} - ${errorText}`);
        }

        const result = await response.json();
        if (result.candidates &amp;&amp; result.candidates.length &gt; 0 &amp;&amp; result.candidates[0].content &amp;&amp; result.candidates[0].content.parts &amp;&amp; result.candidates[0].content.parts.length &gt; 0) {
            const adviceText = result.candidates[0].content.parts[0].text;
            showMessage(`CONSEIL DE POXEL : ${adviceText}`, 'ai-advice');
            speak(`Conseil de Poxel : ${adviceText}`);
        } else {
            showMessage("Poxel n'a pas pu générer de conseil pour le moment.", 'warning');
        }
    } catch (error) {
        console.error("Erreur lors de la génération du conseil de l'IA:", error);
        showMessage(`ERREUR DE L'IA: ${error.message}`, 'error');
    }
}

// Modale de confirmation générique
function showConfirmModal(message) {
    return new Promise(resolve =&gt; {
        const modalDiv = document.createElement('div');
        modalDiv.id = 'confirm-modal';
        modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 font-vt323';
        modalDiv.innerHTML = `
            &lt;div class="bg-gray-800 p-6 rounded-lg border-4 border-yellow-500 shadow-xl w-full max-w-sm text-white text-center"&gt;
                &lt;h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300"&gt;CONFIRMATION&lt;/h3&gt;
                &lt;p class="text-base sm:text-lg mb-6"&gt;${String(message).toUpperCase()}&lt;/p&gt;
                &lt;div class="flex justify-center space-x-4"&gt;
                    &lt;button id="confirm-no" class="btn-retro-red"&gt;ANNULER&lt;/button&gt;
                    &lt;button id="confirm-yes" class="btn-retro-green"&gt;CONFIRMER&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        `;
        document.getElementById('global-modals-container').appendChild(modalDiv);

        document.getElementById('confirm-yes').onclick = () =&gt; {
            modalDiv.remove();
            resolve(true);
        };
        document.getElementById('confirm-no').onclick = () =&gt; {
            modalDiv.remove();
            resolve(false);
        };
    });
}
function showEditIntervalModal(intervalIndex) {
    const intervalToEdit = chronoIntervals[intervalIndex];
    if (!intervalToEdit) {
        showMessage("ERREUR: INTERVALLE NON TROUVÉ POUR MODIFICATION.", 'error');
        return;
    }

    const initialMinutes = Math.floor(intervalToEdit.duration / 60);
    const initialSeconds = intervalToEdit.duration % 60;

    let modalHtml = `
        &lt;div id="edit-interval-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 font-vt323"&gt;
            &lt;div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white"&gt;
                &lt;h3 class="text-2xl sm:text-3xl font-bold text-yellow-300 mb-4 text-center"&gt;MODIFIER L'INTERVALLE&lt;/h3&gt;
                &lt;div class="space-y-4"&gt;
                    &lt;div class="flex flex-col sm:flex-row gap-4"&gt;
                        &lt;div class="flex-1"&gt;
                            &lt;label for="edit-duration-minutes" class="block text-gray-200 text-sm font-bold mb-2"&gt;DURÉE (MINUTES) :&lt;/label&gt;
                            &lt;input type="number" id="edit-duration-minutes" class="input-retro" placeholder="EX: 1" min="0" value="${initialMinutes}" /&gt;
                        &lt;/div&gt;
                        &lt;div class="flex-1"&gt;
                            &lt;label for="edit-duration-seconds" class="block text-gray-200 text-sm font-bold mb-2"&gt;DURÉE (SECONDES) :&lt;/label&gt;
                            &lt;input type="number" id="edit-duration-seconds" class="input-retro" placeholder="EX: 30" min="0" max="59" value="${initialSeconds}" /&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div&gt;
                        &lt;label for="edit-instruction" class="block text-gray-200 text-sm font-bold mb-2"&gt;INSTRUCTION :&lt;/label&gt;
                        &lt;input type="text" id="edit-instruction" class="input-retro" placeholder="EX: COURSE RAPIDE" value="${intervalToEdit.instruction}" /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="flex justify-end space-x-4 mt-6"&gt;
                    &lt;button id="cancel-edit-interval-btn" class="btn-retro-red"&gt;ANNULER&lt;/button&gt;
                    &lt;button id="confirm-edit-interval-btn" class="btn-retro-green"&gt;CONFIRMER MODIFICATION&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `;

    // Insère le HTML de la modale dans le conteneur global
    document.getElementById('global-modals-container').innerHTML = modalHtml;


    // IMPORTANT : On récupère la référence à la modale APRÈS qu'elle ait été insérée dans le DOM
    const modal = document.getElementById('edit-interval-modal'); 
    
    // On stocke l'index de l'intervalle directement sur l'élément de la modale
    // Cela permet de le récupérer facilement quand le bouton de confirmation est cliqué
    modal.dataset.editingIndex = intervalIndex; 


    // Références aux champs de saisie de la modale
    const editDurationMinutesInput = modal.querySelector('#edit-duration-minutes');
    const editDurationSecondsInput = modal.querySelector('#edit-duration-seconds'); // Nouvelle référence pour les secondes
    const editInstructionInput = modal.querySelector('#edit-instruction');


    // Gère le clic sur le bouton "ANNULER" : ferme la modale
    modal.querySelector('#cancel-edit-interval-btn').onclick = () =&gt; modal.remove();


    // Gère le clic sur le bouton "CONFIRMER MODIFICATION"
    modal.querySelector('#confirm-edit-interval-btn').onclick = () =&gt; {
        const newMinutes = parseInt(editDurationMinutesInput.value) || 0;
        const newSeconds = parseInt(editDurationSecondsInput.value) || 0; // Récupère les nouvelles secondes
        const newInstruction = editInstructionInput.value;


        // Récupère l'index de l'intervalle à modifier à partir des données de la modale
        const currentIntervalIndex = parseInt(modal.dataset.editingIndex); 


        if (newMinutes === 0 &amp;&amp; newSeconds === 0) { // Vérifie que la durée n'est pas nulle
            showMessage("ERREUR: LA DURÉE (MINUTES OU SECONDES) EST REQUISE.", 'error');
            return;
        }
        if (newInstruction.trim() === '') {
            showMessage("ERREUR: L'INSTRUCTION EST REQUISE.", 'error');
            return;
        }

        const newDurationTotalSeconds = (newMinutes * 60) + newSeconds; // Calcule la durée totale


        // Vérifie que l'index est valide et qu'il correspond bien à un intervalle existant
        if (isNaN(currentIntervalIndex) || currentIntervalIndex &lt; 0 || currentIntervalIndex &gt;= chronoIntervals.length) {
            console.error("Erreur: Index d'intervalle invalide pour la modification.");
            showMessage("ERREUR: Impossible de trouver l'intervalle à modifier.", 'error');
            return;
        }


        // Met à jour l'objet spécifique dans le tableau chronoIntervals avec les nouvelles valeurs
        chronoIntervals[currentIntervalIndex].duration = newDurationTotalSeconds;
        chronoIntervals[currentIntervalIndex].instruction = newInstruction.trim();


        updateLocalStorageChronoState(); // Sauvegarde le tableau chronoIntervals mis à jour
        showMessage("INTERVALLE MISE À JOUR !", 'success');
        modal.remove(); // Ferme la modale après la modification
        renderIntervalsList(); // Re-rend la liste des intervalles pour afficher les changements
    };
}


// Synchronize breakfast/snack meals across similar days
function syncSimilarMeals(generatedMeal, originalDateKey) {
    if (!generatedMeal || !generatedMeal.mealType || !(generatedMeal.mealType === 'petit_dejeuner' || generatedMeal.mealType.startsWith('collation'))) return;

    const originalDayContext = generatedMeal.dayContext;
    let updatedCount = 0;

    weeklyMealPlan.semaine.forEach(dayData =&gt; {
        const isSimilarDay = dayData.dayContext.poste === originalDayContext.poste &amp;&amp; dayData.dayContext.sport === originalDayContext.sport;

        // Only update if it's a similar day AND not the original day that triggered the regeneration
        if (isSimilarDay &amp;&amp; dayData.date !== originalDateKey) {
            dayData[generatedMeal.mealType] = { ...generatedMeal };
            updatedCount++;
        }
    });

    if (updatedCount &gt; 0) showMessage(`SUCCÈS: ${updatedCount} REPAS SIMILAIRES MIS À JOUR !`, 'success');
}

// Calorie needs estimates based on shift type and sport type
const dailyCalorieNeedsEstimates = {
    '6h-18h': { base: 2500, sport_modifier: { 'renforcement': 300, 'cardio': 200, 'hiit': 400, 'repos_actif': 100, 'aucun': 0 } },
    '7h-18h': { base: 2500, sport_modifier: { 'renforcement': 300, 'cardio': 200, 'hiit': 400, 'repos_actif': 100, 'aucun': 0 } },
    '18h-6h': { base: 2200, sport_modifier: { 'renforcement': 300, 'cardio': 200, 'hiit': 400, 'repos_actif': 100, 'aucun': 0 } },
    'repos': { base: 2000, sport_modifier: { 'renforcement': 300, 'cardio': 200, 'hiit': 400, 'repos_actif': 100, 'aucun': 0 } },
    'repos_sport': { base: 2800, sport_modifier: { 'renforcement': 0, 'cardio': 0, 'hiit': 0, 'repos_actif': 0, 'aucun': 0 } } // repos_sport already implies sport, so no extra modifier
};

function getDailyCalorieNeeds(shiftType, sportType) {
    const type = String(shiftType || 'repos');
    const sport = String(sportType || 'aucun');
    const estimate = dailyCalorieNeedsEstimates[type];
    if (estimate) {
        if (type === 'repos_sport') {
            return estimate.base;
        } else {
            return estimate.base + (estimate.sport_modifier[sport] || 0);
        }
    }
    return 2200; // Default fallback
}

// Fonctions pour la génération de repas par l'IA
function getMealContextKey(mealType, dayContext) { return `${mealType}_${dayContext.poste}_${dayContext.sport}`; }

// MODIFIED generateInternalMeal function
async function generateInternalMeal(mealType, dayContext, existingMealsToday = [], likedMeal = null, allowMeatFish, userProfileData, numPeople, nutritionalProgramText) {
    const apiKey = userProfileData.apiKey || "";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;


    console.log(`[API KEY DEBUG] Using API Key: ${apiKey ? 'Provided (length: ' + apiKey.length + ')' : 'Empty (expecting Canvas injection)'}`);
    console.log(`[API KEY DEBUG] API URL: ${apiUrl}`);


    const userHeight = userProfileData.height;
    const userWeight = userProfileData.weight;
    const userImc = userProfileData.imc;
    const userImcCategory = userProfileData.imcCategory;
    const userProteinNeeds = userProfileData.proteinNeeds;


    let actualNumPeople = numPeople;
    if (mealType === 'petit_dejeuner' || mealType.startsWith('collation')) {
        actualNumPeople = 1; // Force à 1 personne pour le petit-déjeuner et les collations
    }


    let mealContextDescription = getMealMomentContext(mealType, dayContext.poste, dayContext.sport);
    let sportImpact = "";
    if (dayContext.sport !== 'aucun') sportImpact = "CE JOUR INCLUT UNE SÉANCE DE SPORT. LE REPAS DOIT SOUTENIR LA PERFORMANCE OU LA RÉCUPÉRATION.";
    else sportImpact = "CE JOUR N'INCLUT PAS DE SÉANCE DE SPORT. LE REPAS DOIT ÊTRE ÉQUILIBRÉ POUR UN JOUR MOINS ACTIF.";


    let posteImpact = "";
    if (dayContext.poste === '18h-6h') posteImpact = "C'EST UN POSTE DE NUIT. L'ALIMENTATION DOIT ÊTRE ADAPTÉE POUR MAINTENIR L'ÉNERGIE ET LA VIGILANCE PENDANT LA NUIT, ET FAVORISER LE REPOS EN JOURNÉE.";
    else if (dayContext.poste.includes('jour')) posteImpact = "C'EST UN POSTE DE JOUR. L'ALIMENTATION DOIT APPORTER UNE ÉNERGIE DURABLE POUR LA JOURNÉE.";
    else if (dayContext.poste.includes('repos')) posteImpact = "C'EST UN JOUR DE REPOS. L'ALIMENTATION DOIT FAVORISER LA RÉCUPÉRATION ET LE MAINTIEN.";


    let mealSpecificConstraints = [];
    const adviceKey = mealType.includes('collation') ? `${mealType.replace('_unique', '')}_${dayContext.poste === '18h-6h' ? 'pendant' : (dayContext.sport !== 'aucun' ? 'post' : (dayContext.poste === '7h-18h' ? '7h-18h_apresmidi' : 'repos_default'))}` : dayContext.poste === '18h-6h' ? '18h-6h' : (dayContext.sport !== 'aucun' ? 'repos_sport' : 'default');
    const advice = specificMealAdvice[mealType]?.[adviceKey] || specificMealAdvice[mealType]?.default || "CONSEIL GÉNÉRAL : MANGEZ ÉQUILIBRÉ.";
    mealSpecificConstraints.push(advice);


   if (!allowMeatFish) {
        mealSpecificConstraints.push("EXCLURE STRICTEMENT TOUTE VIANDE (ROUGE OU BLANCHE) ET POISSON. PRIVILÉGIER LES PROTÉINES VÉGÉTALES (LÉGUMINEUSES COMME LENTILLES, POIS CHICHES, HARICOTS ROUGES; TOFU, TEMPEH, SEITAN), LES CÉRÉALES COMPLÈTES À HAUTE TENEUR EN PROTÉINES (QUINOA, SARRASIN, AMARANTE), LES ŒUFS, ET LES PRODUITS LAITIERS (FROMAGE BLANC, YAOURT GREC) SI APPLICABLE AU TYPE DE REPAS. ASSURER UNE DIVERSITÉ RÉELLE ET SYSTÉMATIQUE DES SOURCES DE PROTÉINES VÉGÉTALES ET AUTRES, NE PAS SE LIMITER AUX LENTILLES OU AU TOFU. VARIER LES PRÉPARATIONS ET LES SAVEURS.");
    } else { mealSpecificConstraints.push("POUR LA PROTÉINE, IL EST **IMPÉRATIF** DE CHOISIR UNE TRÈS GRANDE DIVERSITÉ DE SOURCES : VIANDE (ROUGE ET BLANCHE), POISSONS (MAIGRES ET GRAS), ŒUFS, LÉGUMINEUSES (LENTILLES, POIS CHICHES, HARICOTS), TOFU, TEMPEH, OU PRODUITS LAITIERS (FROMAGE BLANC, YAOURT GREC). LA GÉNÉRATION DOIT VISER UNE VRAIE ALTERNANCE QUOTIDIENNE ENTRE CES CATÉGORIES ET **NE PAS SE LIMITER EXCLUSIVEMENT À LA VIANDE ET AU POISSON**, MÊME LORSQU'ILS SONT AUTORISÉS. PRIORISER LA VARIÉTÉ SUR PLUSIEURS JOURS.");
    }


    if (mealType === 'petit_dejeuner') {
        mealSpecificConstraints.push("DOIT ÊTRE UN PETIT-DÉJEUNER COHÉRENT ET RÉALISTE. AUCUNE COMBINAISON ABSURDE (EX: POULET DANS UN PANCAKE SUCRÉ).");
        mealSpecificConstraints.push("DOIT ÊTRE SUCRÉ, EN ÉVITANT LES SAVEURS SALÉES (SAUF SI LES ŒUFS SONT INTÉGRÉS DANS UNE PRÉPARATION SUCRÉE COMME DES CRÊPES/PANCAKES).");
        mealSpecificConstraints.push("LES ŒUFS NE PEUVENT ÊTRE UTILISÉS QUE S'ILS SONT INTÉGRÉS DANS DES PRÉPARATIONS COMME DES CRÊPES, DES PANCAKES OU DES PORRIDGES, PAS COMME PLAT PRINCIPAL (EX: ŒUFS BROUILLÉS, OMELETTE).");
        mealSpecificConstraints.push("PAS DE PÂTES, SEMOULE OU SAUCE TOMATE.");
        mealSpecificConstraints.push("EXIGEZ UNE TRÈS GRANDE VARIÉTÉ DE PETITS-DÉJEUNERS DU MONDE ENTIER. IL EST IMPÉRATIF DE PROPOSER UNE DIVERSITÉ DE TYPES DE PETITS-DÉJEUNERS ET DE NE PAS RÉPÉTER LE MÊME TYPE (EX: PORRIDGE) DE MANIÈRE SYSTÉMATIQUE, MÊME LES JOURS DE SPORT. LE PORRIDGE EST UNE OPTION VALIDE, MAIS IL NE DOIT PAS ÊTRE PRÉDOMINANT. INCLURE DES OPTIONS DIVERSES COMME : TARTINES (MIEL, BEURRE, BEURRE DE CACAHUÈTE, CONFITURE), THÉ (AVEC OU SANS LAIT), PORRIDGE (occasionnellement, mais jamais de manière répétée), SHAKE DE WHEY (si le contexte sportif le permet), CÉRÉALES COMPLÈTES, FRUITS FRAIS ET SECS, YAOURTS (GREC, NATURE), SMOOTHIES, CRÊPES, PANCAKES, GAUFRES, PAINS AU LAIT, VIENNOISERIES (très occasionnellement), FRUITS DE SAISON. ADAPTEZ LES OPTIONS AU TYPE DE SÉANCE POUR ÉVITER LES DÉPENSES INUTILES.");
        if (dayContext.sport === 'renforcement') {
            mealSpecificConstraints.push("POUR LE RENFORCEMENT MUSCULAIRE, LE PETIT-DÉJEUNER DOIT APPORTER UNE BONNE SOURCE DE GLUCIDES LENTS ET DE PROTÉINES POUR L'ÉNERGIE ET LA RÉCUPÉRATION. UNE TRÈS GRANDE DIVERSITÉ D'OPTIONS ÉQUILIBRÉES EST ATTENDUE, LE PORRIDGE ÉTANT UNE OPTION PARMI D'AUTRES, PAS LA SEULE OU LA PLUS FRÉQUENTE.");
        } else if (dayContext.sport === 'cardio' || dayContext.sport === 'hiit') {
            mealSpecificConstraints.push("POUR LES SÉANCES DE CARDIO OU HIIT, LE PETIT-DÉJEUNER DOIT ÊTRE ÉNERGISANT ET FACILEMENT DIGESTIBLE POUR NE PAS GÊNER L'ENTRAÎNEMENT. PROPOSEZ UNE VASTE GAMME D'OPTIONS VARIÉES ET ÉQUILIBRÉES, EN INCLUANT LE PORRIDGE COMME UNE OPTION OCCASIONNELLE, MAIS EN PRIVILÉGIANT LA NOUVEAUTÉ ET LA DIVERSITÉ.");
        }
    } else if (mealType.includes('collation')) {
        mealSpecificConstraints.push("DOIT ÊTRE UNE COLLATON LÉGÈRE ET ÉNERGISANTE. PAS UN REPAS COMPLET. DOIT ÊTRE FACILE À TRANSPORTER.");
        mealSpecificConstraints.push("EXEMPLES : FRUITS (BANANE, POMME), YAOURTS, SHAKES PROTÉINÉS, PETITES POIGNÉES D'OLÉAGINEUX (AMANDES, NOIX), BARRES CÉRÉALES MAISON, FRUITS SECS.");
        mealSpecificConstraints.push("ÉVITEZ LES ALIMENTS TROP GRAS OU TROP SUCRÉS.");
        mealSpecificConstraints.push("PROPOSEZ UNE TRÈS GRANDE VARIÉTÉ DE COLLATIONS DU MONDE ENTIER.");
    } else if (mealType === 'dejeuner' || mealType === 'diner') {
        mealSpecificConstraints.push("DOIT ÊTRE UN REPAS COMPLET ET ÉQUILIBRÉ AVEC PROTÉINES, GLUCIDES ET LÉGUMES. DOIT ÊTRE COHÉRENT ET RÉALISTE, SANS COMBINAISONS ABSURDES.");
        mealSpecificConstraints.push("PROPOSEZ UNE TRÈS GRANDE VARIÉTÉ DE RECETTES POUR ÉVITER LA MONOTONIE : SALADES (VERTE, ICEBERG, CRUDITÉS, POMMES DE TERRE, RIZ, PÂTES), GALETTES DE POMMES DE TERRE, RECETTES AVEC DU PAIN (EX: PAIN AVEC FROMAGE, TOASTS PROTÉINÉS, SANDWICHS ÉQUILIBRÉS), BURGERS ET WRAPS (ADAPTÉS AU PROGRAMME NUTRITIONNEL).");
        mealSpecificConstraints.push("ALTERNEZ SYSTÉMATIQUEMENT LES TYPES DE PROTÉINES, GLUCIDES ET LÉGUMES. INCLUEZ FRÉQUEMMENT PÂTES COMPLÈTES, SPAGHETTIS, PÂTES FRAÎCHES, RIZ BASMATI, QUINOA, PATATE DOUCE, SEMOULE COMPLÈTE. LÉGUMES VARIÉS: CONCOMBRE, ARTICHAUD, BROCOLIS, POIVRONS, HARICOTS VERTS, COURGETTES, ÉPINARDS, CAROTTES, CHOU-FLEUR, TOMATES CERISES, LAITUE, RADIS, CHAMPIGNONS, AUBERGINE, OIGNON.");
        mealSpecificConstraints.push("LES RECETTES PEUVENT ÊTRE ISSUES D'AUTRES CULTURES OU CUISINES DU MONDE, MAIS DOIVENT TOUJOURS RESPECTER LE PROGRAMME SPORTIF ET NUTRITIONNEL, ET ÊTRE RÉALISTES.");
    }


    let existingMealsPrompt = "";
    if (existingMealsToday.length &gt; 0) {
        existingMealsToday.forEach(meal =&gt; { existingMealsPrompt += `- ${meal.title} (${meal.mealType})\n`; });
        mealSpecificConstraints.push(`PRENEZ EN COMPTE LES AUTRES REPAS DÉJÀ GÉNÉRÉS POUR CE JOUR POUR ASSURER LA VARIÉTÉ ET ÉVITER LES DOUBLONS D'INGRÉDIENTS OU DE PRÉPARATIONS. REPAS DÉJÀ PRÉVUS POUR CE JOUR : ${existingMealsPrompt}`);
    }


    if (likedMeal) mealSpecificConstraints.push(`L'UTILISATEUR A AIMÉ LA RECETTE SUIVANTE. UTILISEZ-LA COMME INSPIRATION POUR GÉNÉRER UNE NOUVELLE RECETTE SIMILAIRE, MAIS PAS IDENTIQUE, EN VARIANT LÉGÈREMENT LES INGRÉDIENTS OU LA PRÉPARATION POUR ÉVITER LA MONOTONIE ET CONTINUER À OFFRIR DE LA NOUVELLE. RECETTE AIMÉE : TITRE: ${likedMeal.title}, DESCRIPTION: ${likedMeal.description_du_plat}, INGRÉDIENTS: ${likedMeal.ingredients_list.join(', ')}.`);


    if (userProfileData.dislikedMeals &amp;&amp; userProfileData.dislikedMeals.length &gt; 0) {
        const dislikedMealTitles = userProfileData.dislikedMeals.map(dm =&gt; dm.title).join(', ');
        mealSpecificConstraints.push(`NE PROPOSEZ JAMAIS LES RECETTES SUIVANTES CAR L'UTILISATEUR NE LES A PAS AIMÉES : ${dislikedMealTitles}. ASSUREZ-VOUS DE PROPOSER UNE RECETTE COMPLÈTEMENT DIFFÉRENTE SI UNE RECETTE SIMILAIRE EST DANS CETTE LISTE. MAINTENEZ TOUJOURS UNE TRÈS GRANDE VARIÉTÉ, MÊME SI BEAUCOUP DE REPAS SONT DÉSAIMÉS.`);
    }
    // Contrainte pour les protéines en poudre
if (preferPowderedProtein) {
    mealSpecificConstraints.push("AUGMENTER LA FRÉQUENCE DES PROPOSITIONS DE REPAS CONTENANT DES PROTÉINES EN POUDRE (TYPE WHEY). LES INTÉGRER DANS LES PETITS-DÉJEUNERS, COLLATIONS, OU COMME ALTERNATIVE RAPIDE POUR LES REPAS PRINCIPAUX SI LE CONTEXTE LE PERMET. MAINTENIR LA VARIÉTÉ GLOBALE DES SOURCES DE PROTÉINES (ANIMALES, VÉGÉTALES) MAIS AVEC UNE PRÉSENCE ACCRUE DE LA WHEY.");
} else {
    mealSpecificConstraints.push("PROPOSER UNE VARIÉTÉ ÉQUILIBRÉE DE SOURCES DE PROTÉINES : ANIMALES (VIANDE, POISSON, ŒUFS) ET VÉGÉTALES (LÉGUMINEUSES, TOFU, TEMPEH). LES PROTÉINES EN POUDRE PEUVENT ÊTRE UTILISÉES OCCASIONNELLEMENT SI PERTINENT POUR LE TYPE DE REPAS (EX: PETIT-DÉJEUNER, COLLATION), MAIS NE DOIVENT PAS ÊTRE PRÉDOMINANTES.");
}

// AJOUT DE CETTE CONTRAINTE POUR S'ASSURER QUE L'IA FOURNIT LES CALORIES POUR 1 PERSONNE
mealSpecificConstraints.push("L'ESTIMATION DES CALORIES DANS le champ 'calories_kcal' DOIT TOUJOURS ÊTRE UNIQUEMENT POUR 1 PERSONNE, MÊME SI LA RECETTE EST POUR PLUSIEURS PERSONNES.");
    // AJOUT DE CETTE CONTRAINTE POUR S'ASSURER QUE L'IA FOURNIT LES CALORIES POUR 1 PERSONNE
    mealSpecificConstraints.push("L'ESTIMATION DES CALORIES DANS le champ 'calories_kcal' DOIT TOUJOURS ÊTRE UNIQUEMENT POUR 1 PERSONNE, MÊME SI LA RECETTE EST POUR PLUSIEURS PERSONNES.");


    // Ajout de la liste des recettes Basic-Fit au prompt
    let basicFitRecipesPrompt = "";
    const mealTypeKey = mealType.replace('_', '-').toUpperCase(); // Convertir 'petit_dejeuner' en 'PETIT-DÉJEUNER' etc.
    if (basicFitRecipes[mealTypeKey] &amp;&amp; basicFitRecipes[mealTypeKey].length &gt; 0) {
    basicFitRecipesPrompt = `
    CONSIDÉREZ ÉGALEMENT LES RECETTES SUIVANTES DE BASIC-FIT COMME SOURCES D'INSPIRATION SUPPLÉMENTAIRES. POUR MAINTENIR LA VARIÉTÉ ET NE PAS LES PROPOSER SYSTÉMATIQUEMENT, INTÉGREZ-LES OCCASIONNELLEMENT (environ 10-20% des cas pour ce type de repas) PARMI VOS SUGGESTIONS HABITUELLES. SI VOUS PROPOSEZ UNE DE CES RECETTES, AJOUTEZ "[BASIC-FIT]" AU DÉBUT DU TITRE DE LA RECETTE.
    Liste des recettes Basic-Fit pour ce type de repas :
    ${basicFitRecipes[mealTypeKey].map(recipe =&gt; `- ${recipe}`).join('\n')}
    `;
}


    const prompt = `
        Génère une recette de repas pour ${actualNumPeople} personne(s) au format JSON.
        Le repas est de type : "${mealType}".
        Le contexte du jour est : "${getDayContextString(dayContext.poste, dayContext.sport)}".
        Profil utilisateur : Taille: ${userHeight}cm, Poids: ${userWeight}kg, IMC: ${userImc} (${userImcCategory}), Besoins en protéines: ${userProteinNeeds}g/jour.
        ${sportImpact}
        ${posteImpact}


        PROGRAMME NUTRITIONNEL DÉTAILLÉ À RESPECTER STRICTEMENT :
        ${userProfileData.nutritionalProgramText}


        CONTRAINTES SPÉCIFIQUES POUR CE REPAS :
        - Toutes les informations (titre, description, ingrédients, étapes de préparation, conseils, notes) doivent être STRICTEMENT EN FRANÇAIS.
        - Les quantités des ingrédients doivent être adaptées pour ${actualNumPeople} personne(s) et clairement indiquées (ex: 150g, 2 pièces, 1 cuillère à soupe).
        - GÉNÈRE UNIQUEMENT DES RECETTES EXISTANTES, RÉALISTES ET LOGIQUES. AUCUNE COMBINAISON ABSURDE OU NON EXISTANTE (EX: UN WRAP AU POULET ET AUX FRUITS ROUGES).
        - ASSURE UNE TRÈS GRANDE VARIÉTÉ POUR ÉVITER LA MONOTONIE.
        - POUR LES REPAS PRINCIPAUX (DÉJEUNER ET DÎNER) : Si le contexte (type de poste et séance sportive) est identique à un jour précédent, vous pouvez proposer une recette similaire ou réutiliser des ingrédients clés pour optimiser les courses, mais EFFORCEZ-VOUS DE RENDRE CHAQUE RECETTE UNIQUE OU AVEC UNE TOUCHE DIFFÉRENTE.
        - POUR LES COLLATIONS ET PETITS-DÉJEUNERS : Les recettes doivent être variées, faciles à transporter si applicable, compatibles avec le programme sport/nutrition. Si ce repas est généré pour un jour donné, toutes les autres collations/petits-déjeuners du même type de poste ou de séance dans la même semaine devraient être identiques pour assurer la cohérence et la simplicité. Si une nouvelle génération est demandée pour ce type de repas, proposez de nouvelles recettes.
        - Chaque recette DOIT inclure des instructions de cuisson EXTRÊMEMENT DÉTAILLÉES pour CHAQUE composant du plat (par exemple, si c'est du poulet grillé, expliquez comment le mariner, le temps et la température de cuisson, comment vérifier la cuisson, etc.). Ne vous contentez PAS de mentionner un ingrédient sans expliquer sa préparation complète.
        - Pour TOUS les éléments de la recette (viande, poisson, légumes, accompagnements), détaillez la méthode de cuisson (ex: température précise du four, temps de cuisson exact, techniques comme 'faire mariner', 'saisir à feu vif', 'mijoter à couvert', 'blanchir', 'rôtir').
        - Décrivez PRÉCISÉMENT les assaisonnements et les herbes aromatiques à utiliser pour chaque partie du plat, avec des quantités si possible (ex: "une pincée de sel", "une cuillère à café de paprika fumé").
        - Si un plat est simple (ex: 'riz', 'salade verte'), fournissez des instructions de préparation complètes pour cet élément (ex: "comment cuire le riz", "comment laver et assaisonner la salade").
        - Les étapes de préparation doivent être CLAIRES, CONCISES et SUFFISAMMENT DÉTAILLÉES pour qu'un DÉBUTANT ABSOLU puisse suivre la recette sans aucune difficulté. Incluez des conseils de timing et de technique (ex: "cuire jusqu'à ce que les bords soient dorés").
        - Mentionnez TOUJOURS la température de cuisson et le temps de cuisson EXACT pour chaque étape où cela est applicable.
        - INDIQUEZ TOUJOURS LE PAYS OU LA RÉGION D'ORIGINE DE LA RECETTE DANS LE CHAMP "country_of_origin". SI C'EST UN PLAT GÉNÉRAL, INDIQUEZ "INTERNATIONAL" OU "CLASSIQUE".
        ${mealSpecificConstraints.map(c =&gt; `- ${c}`).join('\n')}


        ${basicFitRecipesPrompt}


        Format de sortie JSON attendu :
        {
            "title": "TITRE DU PLAT (EX: POULET GRILLÉ ET LÉGUMES)",
            "description_du_plat": "DESCRIPTION DÉTAILLÉE DU PLAT.",
            "ingredients_label": "INGRÉDIENTS (POUR X PERS)",
            "ingredients_list": ["QUANTITÉ UNITÉ INGRÉDIENT 1", "QUANTITÉ UNITÉ INGRÉDIENT 2", ...],
            "preparation_steps": ["ÉTAPE 1.", "ÉTAPE 2.", ...],
            "ma_portion_waeky": "VOTRE PORTION (POUR WAEKY - TOUJOURS POUR 1 PERSONNE, AVEC ESTIMATION CALORIQUE)",
            "calories_kcal": "ESTIMATION DES CALORIES POUR UNE SEULE PERSONNE (EX: 500)",
            "conseils_reutilisation_economie": "CONSEILS POUR RÉUTILISER LES RESTES OU ÉCONOMISER.",
            "notes": "NOTES SUPPLÉMENTAIRES OU INFORMATIONS NUTRITIONNELLES.",
            "country_of_origin": "PAYS D'ORIGINE (EX: FRANCE, ITALIE, JAPON)"
        }
    `;


    const payload = {
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "OBJECT",
                properties: {
                    "title": { "type": "STRING" },
                    "description_du_plat": { "type": "STRING" },
                    "ingredients_label": { "type": "STRING", "default": `INGRÉDIENTS (POUR ${actualNumPeople} PERS)` }, // Garde le label pour le nombre de personnes
                    "ingredients_list": { "type": "ARRAY", "items": { "type": "STRING" } },
                    "preparation_steps": { "type": "ARRAY", "items": { "type": "STRING" } },
                    "ma_portion_waeky": { "type": "STRING" },
                    "calories_kcal": { "type": "NUMBER" }, // Le type reste nombre, c'est l'instruction qui compte
                    "conseils_reutilisation_economie": { "type": "STRING" },
                    "notes": { "type": "STRING" },
                    "country_of_origin": { "type": "STRING" }
                },
                "required": ["title", "description_du_plat", "ingredients_label", "ingredients_list", "preparation_steps", "ma_portion_waeky", "calories_kcal", "conseils_reutilisation_economie", "notes", "country_of_origin"]
            }
        }
    };


    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });


        if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `Erreur HTTP: ${response.status}`;
            if (response.status === 401 || response.status === 403) errorMessage += " - PROBLÈME D'AUTHENTIFICATION API. VÉRIFIEZ L'ACCÈS À L'API GEMINI. (CODE 401/403)";
            else if (errorText) errorMessage += ` - ${errorText}`;
            throw new Error(errorMessage);
        }


        const rawResult = await response.text();
        let parsedContent = null;
        try {
            const result = JSON.parse(rawResult);
            if (result.candidates &amp;&amp; result.candidates.length &gt; 0 &amp;&amp; result.candidates[0].content &amp;&amp; result.candidates[0].content.parts &amp;&amp; result.candidates[0].content.parts.length &gt; 0) {
                parsedContent = JSON.parse(result.candidates[0].content.parts[0].text);
            } else {
                throw new Error("Réponse de l'IA mal formée ou vide.");
            }
        } catch (parseError) {
            console.error("Erreur lors de l'analyse du JSON de la réponse LLM ou de la structure des candidats:", parseError);
            console.error("JSON brut causant l'erreur:", rawResult);
            const fallbackTitle = `${mealContextDescription.toUpperCase()} SIMPLIFIÉ (ERREUR IA)`, fallbackDesc = `UNE ERREUR S'EST PRODUIte LORS DE LA GÉNÉRATION. VOICI UNE RECETTE DE BASE.`, fallbackIngredients = [`QUANTITÉS À DÉFINIR SELON VOTRE APPÉTIT`, `PROTÉINES VARIÉES`, `GLUCIDES COMPLEXES`, `LÉGUMES DE SAISON`], fallbackPreparation = ["1. PRÉPAREZ LES INGRÉDIENTS. 2. CUISEZ SELON VOS MÉTHODES HABITUELLES."], fallbackPortion = "VOTRE PORTION (POUR WAEKY) : PROTÉINES, GLUCIDES ET LÉGUMES/FRUITS VARIÉS ADAPTÉS. POUR 1 PERSONNE.", fallbackCalories = 0, fallbackConseils = "AJUSTEZ LES QUANTITÉS SELON VOS BESOINS. ESSAYEZ DE RÉUTILISER LES RESTES.", fallbackNotes = "LA RECETTE A ÉTÉ SIMPLIFIÉE EN RAISON D'UN PROBLÈME DE COMMUNICATION AVEC L'IA. VÉRIFIEZ LE PROMPT OU L'API.";
            parsedContent = { id: generateUniqueId(), title: fallbackTitle, description_du_plat: fallbackDesc, ingredients_label: `INGRÉDIENTS (POUR ${actualNumPeople} PERS)`, ingredients_list: fallbackIngredients, preparation_steps: fallbackPreparation, ma_portion_waeky: fallbackPortion, calories_kcal: fallbackCalories, conseils_reutilisation_economie: fallbackConseils, notes: fallbackNotes, country_of_origin: "INTERNATIONAL" };
        }


        return {
            id: generateUniqueId(),
            title: String(parsedContent.title || '').toUpperCase(),
            description_du_plat: String(parsedContent.description_du_plat || '').toUpperCase(),
            ingredients_label: String(parsedContent.ingredients_label || `INGRÉDIENTS (POUR ${actualNumPeople} PERS)`).toUpperCase(),
            ingredients_list: (parsedContent.ingredients_list || []).map(item =&gt; String(item).toUpperCase()),
            preparation_steps: (parsedContent.preparation_steps || []).map(step =&gt; String(step).toUpperCase()),
            ma_portion_waeky: String(parsedContent.ma_portion_waeky || '').toUpperCase(),
            calories_kcal: parsedContent.calories_kcal !== undefined ? parseInt(parsedContent.calories_kcal) : 0, // Les calories devraient être déjà pour 1 personne ici
            conseils_reutilisation_economie: String(parsedContent.conseils_reutilisation_economie || '').toUpperCase(),
            notes: String(parsedContent.notes || '').toUpperCase(),
            country_of_origin: String(parsedContent.country_of_origin || 'INTERNATIONAL').toUpperCase(),
            mealType: mealType,
            dayContext: dayContext
        };
    } catch (error) {
        console.error("Erreur fatale lors de l'appel LLM ou de l'analyse JSON générale:", error);
        const fallbackTitle = `${mealContextDescription.toUpperCase()} (ERREUR SYSTÈME)`, fallbackDesc = `UNE ERREUR CRITIQUE S'EST PRODUIte. VEUILLEZ RÉESSAYER.`, fallbackIngredients = [`VÉRIFIEZ VOTRE CONNEXION INTERNET`, `CONTACTEZ LE SUPPORT SI LE PROBLÈME PERSISTE`], fallbackPreparation = ["1. ESSAYEZ DE RE-GÉNÉRER LE PLAN.", "2. ASSUREZ-VOUS QUE VOTRE PROFIL EST COMPLET."], fallbackPortion = "INDISPONIBLE EN RAISON D'UNE ERREUR.", fallbackCalories = 0, fallbackConseils = "AUCUN CONSEIL DISPONIBLE.", fallbackNotes = "ERREUR DE COMMUNICATION MAJEURE AVEC L'IA. VEUILLEZ VÉRIFIER VOTRE CONNEXION.";
        return { id: generateUniqueId(), title: fallbackTitle, description_du_plat: fallbackDesc, ingredients_label: `INGRÉDIENTS (POUR ${actualNumPeople} PERS)`, ingredients_list: fallbackIngredients, preparation_steps: fallbackPreparation, ma_portion_waeky: fallbackPortion, calories_kcal: fallbackCalories, conseils_reutilisation_economie: fallbackConseils, notes: fallbackNotes, mealType: mealType, dayContext: dayContext, country_of_origin: "INTERNATIONAL" };
    }
}
// Rend la vue des recettes et gère la génération du plan de repas
function renderRecipeView(container) {
    // numPeople and allowMeatFish are now global, loaded in initializeGlobalState
    // No need to load them again here, just use the global variables

    let html = `
        &lt;div class="card-retro mb-6"&gt;
            &lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;PLAN DE REPAS&lt;/h2&gt;
            &lt;div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;GÉNÉRER MON PLAN DE REPAS :&lt;/h3&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="numPeople" class="block text-gray-200 text-sm font-bold mb-2"&gt;POUR COMBIEN DE PERSONNES ?&lt;/label&gt;
                    &lt;input type="number" id="numPeople" value="${numPeople}" min="1" class="input-retro" /&gt;
                &lt;/div&gt;
                &lt;!-- Conteneur pour regrouper les options de préférences alimentaires --&gt;
            &lt;div class="space-y-4 mb-4"&gt;
                &lt;div class="flex items-center"&gt;
                    &lt;input type="checkbox" id="allowMeatFish" ${allowMeatFish ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /&gt;
                    &lt;label for="allowMeatFish" class="text-gray-200 text-sm font-bold"&gt;AUTORISER VIANDE ET POISSON (PLUS ÉCONOMIQUE SANS)&lt;/label&gt;
                &lt;/div&gt;
                &lt;!-- Nouvelle encoche pour les protéines en poudre --&gt;
                &lt;div class="flex items-center"&gt;
                    &lt;input type="checkbox" id="preferPowderedProtein" ${preferPowderedProtein ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /&gt;
                    &lt;label for="preferPowderedProtein" class="text-gray-200 text-sm font-bold"&gt;PROPOSITION DE PLUS DE PROTÉINES EN POUDRE&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
                &lt;button id="generate-plan-btn" class="btn-retro-purple w-full flex items-center justify-center" ${regeneratingMeal ? 'disabled' : ''}&gt;
                    &lt;span id="generate-plan-spinner" class="spinner mr-2 ${regeneratingMeal ? '' : 'hidden'}"&gt;&lt;/span&gt;
                    &lt;span id="generate-plan-text"&gt;${regeneratingMeal ? 'GÉNÉRATION...' : 'GÉNÉRER PLAN DE REPAS'}&lt;/span&gt;
                &lt;/button&gt;
                &lt;p class="text-xs text-gray-400 mt-2 text-center"&gt;LE PLAN SERA GÉNÉRÉ UNIQUEMENT POUR LES JOURS AVEC DES POSTES ENREGISTRÉS DANS L'ONGLET "PLANNING".&lt;/p&gt;
            &lt;/div&gt;
            &lt;div id="weekly-meal-plan-content"&gt;&lt;/div&gt;
        &lt;/div&gt;
    `;
    container.innerHTML = html;

    const numPeopleInput = document.getElementById('numPeople');
    const allowMeatFishCheckbox = document.getElementById('allowMeatFish');
    const generatePlanBtn = document.getElementById('generate-plan-btn');
    const generatePlanSpinner = document.getElementById('generate-plan-spinner');
    const generatePlanText = document.getElementById('generate-plan-text');
    const weeklyMealPlanContentDiv = document.getElementById('weekly-meal-plan-content');

    numPeopleInput.value = numPeople;
    allowMeatFishCheckbox.checked = allowMeatFish;

    numPeopleInput.onchange = (e) =&gt; { numPeople = Math.max(1, parseInt(e.target.value) || 1); saveToLocalStorage('recipeNumPeople', numPeople); };
    allowMeatFishCheckbox.onchange = (e) =&gt; { allowMeatFish = e.target.checked; saveToLocalStorage('recipeAllowMeatFish', allowMeatFish); };
    // Gère le changement de la nouvelle encoche
const preferPowderedProteinCheckbox = document.getElementById('preferPowderedProtein');
preferPowderedProteinCheckbox.onchange = (e) =&gt; { preferPowderedProtein = e.target.checked; saveToLocalStorage('preferPowderedProtein', preferPowderedProtein); };
    // Update button state based on regeneratingMeal flag
    if (regeneratingMeal) {
        generatePlanBtn.disabled = true;
        generatePlanSpinner.classList.remove('hidden');
        generatePlanText.textContent = 'GÉNÉRATION...';
    } else {
        generatePlanBtn.disabled = false;
        generatePlanSpinner.classList.add('hidden');
        generatePlanText.textContent = 'GÉNÉRER PLAN DE REPAS';
    }

    generatePlanBtn.onclick = async () =&gt; {
        regeneratingMeal = { dateKey: null, mealType: null }; // Set regeneratingMeal to indicate overall generation
        renderRecipeView(container); // Re-render to show spinner and disabled button

        try {
            if (!userProfile.height || !userProfile.weight) { showMessage("ERREUR: VEUILLEZ REMPLIR VOTRE TAILLE ET VOTRE POIDS DANS LE PROFIL POUR GÉNÉRER DES RECETTES PRÉCISES.", 'error'); return; }

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const fetchedShifts = (loadFromLocalStorage('shifts', []) || []).filter(s =&gt; new Date(s.date).getTime() &gt;= today.getTime());

            if (fetchedShifts.length === 0) { showMessage("AUCUN POSTE ENREGISTRÉ POUR LES JOURS À VENIR. VEUILLEZ AJOUTER DES POSTES DANS L'ONGLET 'PLANNING' POUR GÉNÉRER UN PLAN DE REPAS.", 'warning'); return; }

            const newMealPlan = { semaine: [] };
            const userProfileData = { height: parseFloat(userProfile.height), weight: parseFloat(userProfile.weight), imc: userProfile.imc, imcCategory: userProfile.imcCategory, proteinNeeds: userProfile.proteinNeeds, apiKey: userProfile.apiKey };

            const generatedSimilarMeals = {}; // Key: "shiftType_workoutType_mealType", Value: meal object

            // Sort shifts by date to ensure consistent generation order
            fetchedShifts.sort((a, b) =&gt; new Date(a.date).getTime() - new Date(b.date).getTime());

            for (const shift of fetchedShifts) {
                const day = new Date(shift.date);
                const dateKey = formatDateToYYYYMMDD(day);
                const dayContext = { poste: shift.type, sport: shift.workoutType };
                const mealsForDay = { date: dateKey, dayContext: dayContext };
                // MODIFICATION ICI : Suppression de 'collation_unique'
                const mealOrder = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner'];

                for (const mealType of mealOrder) {
                    // Nouvelle logique pour exclure les collations les jours de repos sans sport
                    if (dayContext.poste === 'repos' &amp;&amp; dayContext.sport === 'aucun') {
                        if (mealType === 'collation_matin' || mealType === 'collation_apresmidi') { // 'collation_unique' already removed
                            console.log(`Skipping ${mealType} for rest day without sport: ${dateKey}`);
                            continue; // Skip this meal type for this day
                        }
                    }

                    let generatedMeal;
                    const relevantLikedMeals = userProfile.likedMeals.filter(lm =&gt; lm.mealType === mealType);
                    const inspirationMeal = relevantLikedMeals.length &gt; 0 ? relevantLikedMeals[Math.floor(Math.random() * relevantLikedMeals.length)] : null;

                    const isSynchronizableMeal = (mealType === 'petit_dejeuner' || mealType.startsWith('collation'));
                    const dayContextKey = `${dayContext.poste}_${dayContext.sport}_${mealType}`;

                    if (isSynchronizableMeal &amp;&amp; generatedSimilarMeals[dayContextKey]) {
                        // Reuse already generated meal for similar context
                        generatedMeal = { ...generatedSimilarMeals[dayContextKey] };
                        generatedMeal.id = generateUniqueId(); // Assign a new unique ID for this instance
                    } else {
                        // Generate new meal
                        generatedMeal = await generateInternalMeal(
                            mealType,
                            dayContext,
                            Object.values(mealsForDay).filter(m =&gt; typeof m === 'object' &amp;&amp; m !== null &amp;&amp; m.mealType &amp;&amp; m.mealType !== mealType),
                            inspirationMeal,
                            allowMeatFish,
                            userProfile, // Passer l'objet userProfile complet
                            numPeople,
                            userProfile.customNutritionalProgramText || nutritionalProgramText // Utilisez le programme personnalisé ou le par défaut
                        );
                        if (isSynchronizableMeal) {
                            // Store for future reuse in this generation cycle
                            generatedSimilarMeals[dayContextKey] = { ...generatedMeal };
                        }
                    }
                    mealsForDay[mealType] = generatedMeal;
                }
                newMealPlan.semaine.push({ date: dateKey, dayContext: dayContext, ...mealsForDay });

            }

            newMealPlan.semaine.sort((a, b) =&gt; new Date(a.date).getTime() - new Date(b.date).getTime());
            weeklyMealPlan = newMealPlan;
            saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
            showMessage("SUCCÈS: PLAN DE REPAS GÉNÉRÉ ET ENREGISTRÉ !", 'success');
            speak("Plan de repas généré !");
        } catch (error) {
            console.error("Erreur lors de la génération du plan de repas:", error);
            showMessage(`ERREUR: Échec de la génération du plan. ${error.message}`, 'error');
        } finally {
            regeneratingMeal = null; // Clear regeneratingMeal flag
            renderRecipeView(container); // Re-render to update UI and re-enable button
        }
    };

    function renderWeeklyMealPlan() {
        if (!weeklyMealPlan || !weeklyMealPlan.semaine || weeklyMealPlan.semaine.length === 0) {
            weeklyMealPlanContentDiv.innerHTML = `&lt;p class="text-gray-400 text-center"&gt;AUCUN PLAN DE REPAS GÉNÉRÉ. CLIQUEZ SUR "GÉNÉRER PLAN DE REPAS" CI-DESSUS.&lt;/p&gt;`;
            return;
        }

        let mealsHtml = `&lt;div class="space-y-6"&gt; &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3 text-center"&gt;TON PLAN DE REPAS :&lt;/h3&gt; `;

        weeklyMealPlan.semaine.forEach((dayData, dayIndex) =&gt; {
            const dateString = new Date(dayData.date).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' }).toUpperCase();
            const dayContextString = getDayContextString(dayData.dayContext.poste, dayData.dayContext.sport);

            // MODIFICATION ICI : Suppression de 'collation_unique' pour le calcul des calories
            const totalDailyCalories = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner'].reduce((sum, mealType) =&gt; {
                const meal = dayData[mealType];
                return sum + (meal &amp;&amp; typeof meal.calories_kcal === 'number' ? meal.calories_kcal : 0);
            }, 0);
            const requiredDailyCalories = getDailyCalorieNeeds(dayData.dayContext.poste, dayData.dayContext.sport);

            mealsHtml += `
                &lt;div class="bg-gray-700 p-4 rounded-lg border-4 border-purple-500 shadow-lg"&gt;
                    &lt;div class="flex flex-col sm:flex-row justify-between items-start sm:items-center cursor-pointer py-2" data-toggle="day-content-${dayData.date}"&gt;
                        &lt;h4 class="text-lg sm:text-xl font-bold text-yellow-300 mb-2 sm:mb-0"&gt;${dateString} - ${dayContextString}&lt;/h4&gt;
                        &lt;i data-lucide="chevron-down" class="text-yellow-300 transition-transform duration-300"&gt;&lt;/i&gt;
                    &lt;/div&gt;
                    &lt;div class="text-sm text-gray-200 mt-2 p-2 bg-gray-600 rounded-md"&gt;
                        &lt;p&gt;CALORIES JOURNÉE : &lt;span class="font-bold text-blue-300"&gt;${totalDailyCalories} KCAL&lt;/span&gt;&lt;/p&gt;
                        &lt;p&gt;BESOIN ESTIMÉ : &lt;span class="font-bold text-blue-300"&gt;${requiredDailyCalories} KCAL&lt;/span&gt;&lt;/p&gt;
                    &lt;/div&gt;
                    &lt;div id="day-content-${dayData.date}" class="overflow-hidden transition-all duration-500 ease-in-out max-h-0"&gt;
                        &lt;div class="space-y-4 pt-2"&gt;
            `;

            // MODIFICATION ICI : Suppression de 'collation_unique'
            const mealOrder = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner'];
            mealOrder.forEach(mealType =&gt; {
                const meal = dayData[mealType];
                const isDisliked = userProfile.dislikedMeals.some(dm =&gt; dm.id === meal?.id);
                if (!meal) {
                    return;
                }

                const momentContext = getMealMomentContext(mealType, dayData.dayContext.poste, dayData.dayContext.sport);
                const adviceKey = mealType.includes('collation') ? `${mealType.replace('_unique', '')}_${dayData.dayContext.poste === '18h-6h' ? 'pendant' : (dayData.dayContext.sport !== 'aucun' ? 'post' : (dayData.dayContext.poste === '7h-18h' ? '7h-18h_apresmidi' : 'repos_default'))}` : dayData.dayContext.poste === '18h-6h' ? '18h-6h' : (dayData.dayContext.sport !== 'aucun' ? 'repos_sport' : 'default');
                const advice = specificMealAdvice[mealType]?.[adviceKey] || specificMealAdvice[mealType]?.default || "CONSEIL GÉNÉRAL : MANGEZ ÉQUILIBRÉ.";
                const isRegeneratingCurrentMeal = regeneratingMeal &amp;&amp; regeneratingMeal.dateKey === dayData.date &amp;&amp; regeneratingMeal.mealType === mealType;
                const isLiked = userProfile.likedMeals.some(lm =&gt; lm.id === meal.id);
                
                mealsHtml += `
                        &lt;div class="bg-gray-800 p-3 rounded-md border border-blue-700 shadow-sm"&gt;
                            &lt;div class="flex justify-between items-center cursor-pointer py-2" data-toggle="meal-content-${meal.id}"&gt;
                                &lt;h5 class="text-lg font-bold text-gray-100"&gt;${momentContext} : ${String(meal.title || 'Titre Indisponible').toUpperCase().replace('[BASIC-FIT]', '&lt;span style="color:#FF6600;"&gt;BASIC-FIT&lt;/span&gt;')} &lt;span class="text-yellow-400 text-sm"&gt;(${meal.calories_kcal} KCAL)&lt;/span&gt;&lt;/h5&gt;
                                &lt;div class="flex items-center"&gt;
                                    &lt;button class="btn-retro-purple text-xs px-2 py-1 flex items-center justify-center regenerate-meal-btn" data-date="${dayData.date}" data-meal-type="${mealType}" ${isRegeneratingCurrentMeal ? 'disabled' : ''}&gt;
                                        ${isRegeneratingCurrentMeal ? `&lt;span class="spinner w-4 h-4"&gt;&lt;/span&gt;` : `&lt;i data-lucide="rotate-ccw" style="width:16px; height:16px;"&gt;&lt;/i&gt;`}
                                        &lt;span class="ml-1 hidden sm:inline"&gt;RÉGÉNÉRER&lt;/span&gt;
                                    &lt;/button&gt;
                                    &lt;button class="text-white ml-2 like-meal-btn" data-meal-id="${meal.id}" data-date="${dayData.date}" data-meal-type="${mealType}" style="color:${isLiked ? '#FCD34D' : 'white'};"&gt;
                                        &lt;i data-lucide="${isLiked ? 'heart' : 'heart'}" class="${isLiked ? 'fill-current text-yellow-400' : ''}" style="width:20px; height:20px;"&gt;&lt;/i&gt;
                                    &lt;/button&gt;
                                    &lt;button class="text-white ml-2 dislike-meal-btn" data-meal-id="${meal.id}" data-date="${dayData.date}" data-meal-type="${mealType}" style="color:${isDisliked ? '#DC2626' : 'white'};"&gt;
                                        &lt;i data-lucide="${isDisliked ? 'x-circle' : 'x-circle'}" class="${isDisliked ? 'fill-current text-red-600' : ''}" style="width:20px; height:20px;"&gt;&lt;/i&gt;
                                    &lt;/button&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div id="meal-content-${meal.id}" class="overflow-hidden transition-all duration-500 ease-in-out max-h-0"&gt;
                                &lt;p class="text-gray-300 text-sm italic mb-2"&gt;${String(meal.description_du_plat || 'DESCRIPTION INDISPONIBLE').toUpperCase()}&lt;/p&gt;
                                &lt;p class="text-sm font-medium text-yellow-300"&gt;${String(meal.ingredients_label || 'INGRÉDIENTS').toUpperCase()} :&lt;/p&gt;
                                &lt;ul class="list-disc list-inside text-gray-300 text-xs pl-2 space-y-1"&gt;${(meal.ingredients_list || []).map(ingredient =&gt; `&lt;li&gt;${String(ingredient).toUpperCase()}&lt;/li&gt;`).join('')}&lt;/ul&gt;
                                &lt;p class="text-sm font-medium text-yellow-300 mt-2"&gt;PRÉPARATION :&lt;/p&gt;
                                &lt;ol class="list-decimal list-inside text-gray-300 text-xs pl-2 space-y-1"&gt;${(meal.preparation_steps || []).map(step =&gt; `&lt;li&gt;${String(step).toUpperCase()}&lt;/li&gt;`).join('')}&lt;/ol&gt;
                                &lt;p class="text-sm font-medium text-yellow-300 mt-2"&gt;PORTION WAEKY :&lt;/p&gt;
                                &lt;p class="text-gray-300 text-xs"&gt;${String(meal.ma_portion_waeky || 'PORTION INDISPONIBLE').toUpperCase()}&lt;/p&gt;
                                &lt;p class="text-sm font-medium text-yellow-300 mt-2"&gt;CONSEILS ÉCONOMIE :&lt;/p&gt;
                                &lt;p class="text-gray-300 text-xs"&gt;${String(meal.conseils_reutilisation_economie || 'CONSEILS INDISPONIBLES').toUpperCase()}&lt;/p&gt;
                                &lt;p class="text-blue-200 text-xs mt-3"&gt;${advice}&lt;/p&gt;
                                ${meal.country_of_origin ? `&lt;p class="text-green-300 text-xs mt-2"&gt;ORIGINE : ${String(meal.country_of_origin).toUpperCase()}&lt;/p&gt;` : ''} &lt;!-- New line for country of origin --&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    `;
            });
            mealsHtml += `&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;`;
        });
        mealsHtml += `&lt;/div&gt;`;
        weeklyMealPlanContentDiv.innerHTML = mealsHtml;
        renderLucideIcons();       // 1. Rendre les icônes en SVG
        attachMealActionListeners(); // 2. Attacher les écouteurs aux boutons (y compris stopPropagation)
        attachCollapsibleListeners(); // 3. Attacher les écouteurs aux volets (avec la vérification closest)
    }
    renderWeeklyMealPlan();
}


// MODIFIED displayDailyMealPlan function
function displayDailyMealPlan(date) {
    const displayContainer = document.getElementById('daily-meal-plan-display');
    const title = document.getElementById('current-day-meal-plan-title');
    const mealsContainer = document.getElementById('current-day-meals');
    const generateMealsBtn = document.getElementById('generate-meals-btn');
    const generateMealsText = document.getElementById('generate-meals-text');
    const generateMealsSpinner = document.getElementById('generate-meals-spinner');

    const dayData = weeklyMealPlan?.semaine?.find(d =&gt; d.date === date);
    const selectedShift = shifts.find(s =&gt; s.date === date);

    title.textContent = `PLAN DE REPAS POUR LE ${formatDate(date)}`;
    mealsContainer.innerHTML = '';

    if (!dayData || Object.keys(dayData).length &lt;= 1) { // Only date property exists
        mealsContainer.innerHTML = `&lt;p class="text-center text-gray-400"&gt;AUCUN REPAS GÉNÉRÉ POUR CE JOUR.&lt;/p&gt;`;
        generateMealsText.textContent = 'GÉNÉRER LES REPAS POUR CE JOUR';
        generateMealsBtn.disabled = false;
    } else {
        // MODIFICATION ICI : Suppression de 'collation_unique'
        const mealOrder = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner'];
        mealOrder.forEach(mealType =&gt; {
            const meal = dayData[mealType];
            const isDisliked = userProfile.dislikedMeals.includes(meal?.id); // Check if meal is disliked
            if (!meal) {
                return;
            }

            const isLiked = userProfile.likedMeals.some(lm =&gt; lm.id === meal.id);

            mealsContainer.innerHTML += `
                &lt;div class="card-retro mb-4 p-4"&gt;
                    &lt;div class="flex justify-between items-center mb-2"&gt;
                        &lt;h4 class="text-xl font-bold text-blue-300"&gt;${meal.mealType.toUpperCase().replace('_', ' ')}: ${String(meal.title || 'Titre Indisponible').toUpperCase().replace('[BASIC-FIT]', '&lt;span style="color:#FF6600;"&gt;BASIC-FIT&lt;/span&gt;')}&lt;/h4&gt;
                        &lt;div class="flex items-center gap-2"&gt;
                            &lt;button class="like-meal-btn btn-icon" data-meal-id="${meal.id}" data-date="${date}" data-meal-type="${mealType}" title="Ajouter aux favoris"&gt;
                                &lt;i class="text-xl" data-lucide="heart" style="color:${isLiked ? '#FCD34D' : 'white'};"&gt;&lt;/i&gt;
                            &lt;/button&gt;
                            &lt;button class="dislike-meal-btn btn-icon" data-meal-id="${meal.id}" data-date="${date}" data-meal-type="${mealType}" title="Ne pas aimer cette recette"&gt;
                                &lt;i class="text-xl" data-lucide="x-circle" style="color:${isDisliked ? '#DC2626' : 'white'};"&gt;&lt;/i&gt;
                            &lt;/button&gt;
                            &lt;button class="regenerate-meal-btn btn-icon" data-meal-id="${meal.id}" data-date="${date}" data-meal-type="${mealType}" title="Regénérer ce repas"&gt;
                                &lt;i class="text-xl" data-lucide="refresh-cw"&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;p class="text-gray-300 text-sm mb-2"&gt;${meal.description_du_plat}&lt;/p&gt;
                    &lt;h5 class="font-bold text-yellow-200 mt-3"&gt;${meal.ingredients_label}&lt;/h5&gt;
                    &lt;ul class="list-disc list-inside text-gray-300 text-sm mb-2"&gt;
                        ${meal.ingredients_list.map(item =&gt; `&lt;li&gt;${item}&lt;/li&gt;`).join('')}
                    &lt;/ul&gt;
                    &lt;h5 class="font-bold text-yellow-200 mt-3"&gt;PRÉPARATION :&lt;/h5&gt;
                    &lt;ol class="list-decimal list-inside text-gray-300 text-sm mb-2"&gt;
                        ${meal.preparation_steps.map(step =&gt; `&lt;li&gt;${step}&lt;/li&gt;`).join('')}
                    &lt;/ol&gt;
                    &lt;p class="text-sm text-green-300 mt-3"&gt;**TA PORTION WAEKY :** ${meal.ma_portion_waeky}&lt;/p&gt;
                    &lt;p class="text-sm text-gray-400"&gt;Calories estimées (pour ${numPeople} pers) : ${meal.calories_kcal} kcal&lt;/p&gt;
                    ${meal.conseils_reutilisation_economie ? `&lt;p class="text-sm text-gray-400"&gt;Conseils : ${meal.conseils_reutilisation_economie}&lt;/p&gt;` : ''}
                    ${meal.notes ? `&lt;p class="text-sm text-gray-400"&gt;Notes : ${meal.notes}&lt;/p&gt;` : ''}
                    ${meal.country_of_origin ? `&lt;p class="text-green-300 text-xs mt-2"&gt;ORIGINE : ${String(meal.country_of_origin).toUpperCase()}&lt;/p&gt;` : ''} &lt;!-- New line for country of origin --&gt;
                &lt;/div&gt;
            `;
        });
        generateMealsText.textContent = 'RÉGÉNÉRER LES REPAS POUR CE JOUR';
        generateMealsBtn.disabled = false;
    }

    displayContainer.classList.remove('hidden');
    renderLucideIcons(); // Render icons for newly added meal cards
    attachMealActionListeners(); // Attach listeners to new meal action buttons
    attachRegenerateMealListeners(); // Attach listeners for regenerate button
}

// Gère l'affichage/masquage des détails de repas
function attachCollapsibleListeners() {
    document.querySelectorAll('[data-toggle]').forEach(toggleElement =&gt; {
        // Remove existing listener to prevent duplicates
        if (toggleElement.dataset.listenerAttached) {
            toggleElement.removeEventListener('click', toggleElement._clickHandler);
        }

        const clickHandler = (event) =&gt; {
          const clickedElement = event.target;
            const isActionButton = clickedElement.closest('.regenerate-meal-btn, .like-meal-btn, .dislike-meal-btn');

            if (isActionButton) {
                // Si un bouton d'action a été cliqué, ne pas ouvrir/fermer le volet
                return;
            }
            const targetId = toggleElement.dataset.toggle;
            const targetContent = document.getElementById(targetId);
            const icon = toggleElement.querySelector('i[data-lucide]');

            if (targetContent) {
                if (targetContent.classList.contains('max-h-0')) {
                    // Expand
                    targetContent.style.maxHeight = targetContent.scrollHeight + 'px';
                    targetContent.classList.remove('max-h-0');
                    if (icon) icon.classList.add('rotate-180');
                    targetContent.classList.add('open');
                    // After transition, set max-height to a very large value to accommodate dynamic content
                    targetContent.addEventListener('transitionend', function handler() {
                        if (targetContent.classList.contains('open')) {
                            targetContent.style.maxHeight = '9999px'; // Allow content to grow
                        }
                        targetContent.removeEventListener('transitionend', handler);
                    }, { once: true });
                } else {
                    // Collapse
                    targetContent.style.maxHeight = targetContent.scrollHeight + 'px'; // Set explicit height before collapsing
                    requestAnimationFrame(() =&gt; {
                        targetContent.classList.add('max-h-0');
                        targetContent.style.maxHeight = '0'; // Collapse
                    });
                    if (icon) icon.classList.remove('rotate-180');
                    targetContent.classList.remove('open');
                }
            }
        };

        toggleElement.addEventListener('click', clickHandler);
        toggleElement._clickHandler = clickHandler; // Store reference to the handler
        toggleElement.dataset.listenerAttached = 'true';
    });
}

// Attach listeners for regenerate, like, and dislike buttons
function attachMealActionListeners() {
    console.log("Fonction attachMealActionListeners appelée !"); // DEBUG: Vérifie si la fonction est appelée

    document.querySelectorAll('.regenerate-meal-btn').forEach(button =&gt; {
        button.onclick = async (event) =&gt; {
            const dateKey = event.currentTarget.dataset.date;
            const mealType = event.currentTarget.dataset.mealType;
            const dayDataForRegen = weeklyMealPlan.semaine.find(d =&gt; d.date === dateKey);

            if (!dayDataForRegen || !dayDataForRegen.dayContext) { showMessage("ERREUR: CONTEXTE DE JOUR NON TROUVÉ POUR LA RÉGÉNÉRATION DU REPAS.", 'error'); return; }

            regeneratingMeal = { dateKey: dateKey, mealType: mealType };
            renderRecipeView(document.getElementById('main-content')); // Re-render to show spinner/disabled state

            try {
                const userProfileData = { height: parseFloat(userProfile.height), weight: parseFloat(userProfile.weight), imc: userProfile.imc, imcCategory: userProfile.imcCategory, proteinNeeds: userProfile.proteinNeeds, apiKey: userProfile.apiKey };
                const regeneratedMeal = await generateInternalMeal(
                    mealType,
                    dayDataForRegen.dayContext,
                    Object.values(dayDataForRegen).filter(m =&gt; typeof m === 'object' &amp;&amp; m !== null &amp;&amp; m.mealType &amp;&amp; m.mealType !== mealType),
                    null, // No specific liked meal inspiration for regeneration of an existing slot
                    allowMeatFish,
                    userProfile, // Passer l'objet userProfile complet
                    numPeople,
                    userProfile.customNutritionalProgramText || nutritionalProgramText // Utilisez le programme personnalisé ou le par défaut
                );

                dayDataForRegen[mealType] = regeneratedMeal;

                // Synchronize breakfast/collation meals on regeneration
                if (mealType === 'petit_dejeuner' || mealType.startsWith('collation')) {
                    syncSimilarMeals(regeneratedMeal, dateKey);
                }

                saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                showMessage("SUCCÈS: REPAS RÉGÉNÉRÉ !", 'success');
                speak("Repas régénéré !");
            } catch (error) {
                console.error("Erreur lors de la régénération du repas:", error);
                showMessage(`ERREUR: ÉCHEC DE LA RÉGÉNÉRATION DU REPAS. ${error.message}`, 'error');
            } finally {
                regeneratingMeal = null; // Clear regeneratingMeal flag
                renderRecipeView(document.getElementById('main-content')); // Re-render to update UI and re-enable button
            }
        };
    });

    document.querySelectorAll('.like-meal-btn').forEach(button =&gt; {
        button.onclick = (event) =&gt; {
            const mealId = button.dataset.mealId;
            const dateKey = button.dataset.date;
            const mealType = button.dataset.mealType;
            const dayData = weeklyMealPlan.semaine.find(d =&gt; d.date === dateKey);
            const mealToLike = dayData ? dayData[mealType] : null;

            if (mealToLike) {
                // Check if the specific meal instance (by its unique ID) is already liked
                const existingLikedIndex = userProfile.likedMeals.findIndex(lm =&gt; lm.id === mealToLike.id);
                if (existingLikedIndex !== -1) {
                    userProfile.likedMeals.splice(existingLikedIndex, 1);
                    showMessage("RECETTE RETIRÉE DES FAVORIS.", 'info');
                } else {
                    // Add the meal to likedMeals, including its context for AI inspiration
                    userProfile.likedMeals.push({
                        id: mealToLike.id,
                        title: mealToLike.title,
                        description_du_plat: mealToLike.description_du_plat,
                        ingredients_list: mealToLike.ingredients_list,
                        mealType: mealToLike.mealType,
                        dayContext: mealToLike.dayContext, // Store day context for better inspiration
                        likedAt: new Date().toISOString()
                    });
                    showMessage("RECETTE AJOUTÉE AUX FAVORIS !", 'success');
                }
                saveToLocalStorage('userProfile', userProfile);
                renderRecipeView(document.getElementById('main-content')); // Re-render to update heart icon
            }
        };
    });

    // LE BLOC DE CODE CORRIGÉ POUR LE BOUTON 'J'AIME PAS' EST MAINTENANT ICI
    document.querySelectorAll('.dislike-meal-btn').forEach(button =&gt; {
        console.log("Bouton 'J'aime pas' trouvé et écouteur attaché !"); // DEBUG: Vérifie si le bouton est trouvé
        button.onclick = (event) =&gt; {
            console.log("Clic sur le bouton 'J'aime pas' détecté !"); // DEBUG: Vérifie si le clic est capturé
            event.stopPropagation(); // Empêche le clic de se propager aux éléments parents

            const mealId = button.dataset.mealId;
            const dateKey = button.dataset.date;
            const mealType = button.dataset.mealType; // Corrected: button.dataset.mealType

            console.log(`ID du repas: ${mealId}, Date: ${dateKey}, Type de repas: ${mealType}`); // DEBUG: Vérifie les données

            // Trouve le jour et le repas correspondant dans le plan hebdomadaire
            const dayData = weeklyMealPlan.semaine.find(d =&gt; d.date === dateKey);
            const mealToDislike = dayData ? dayData[mealType] : null;

            if (mealToDislike) {
                console.log("Repas à 'disliker' trouvé:", mealToDislike); // DEBUG: Vérifie l'objet repas
                // APPEL DE LA FONCTION handleDislikeMeal
                handleDislikeMeal(mealToDislike); // Passe l'objet complet du repas
            } else {
                console.error("ERREUR: Repas à 'disliker' non trouvé dans weeklyMealPlan !", { mealId, dateKey, mealType, dayData, weeklyMealPlan }); // DEBUG: Affiche l'erreur
                showMessage("ERREUR: Impossible de trouver le repas à 'disliker'.", 'error');
            }
        };
    });
}
    // Rend la vue du chronomètre d'intervalle (mise à jour avec entrée des secondes)
function renderChronoIntervalleView(container) {
    let html = `
        &lt;div class="card-retro mb-6"&gt;
            &lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;CHRONOMÈTRE D'INTERVALLES&lt;/h2&gt;


            &lt;!-- Affichage du Chrono --&gt;
            &lt;div class="bg-gray-800 p-6 rounded-lg border-4 border-blue-700 shadow-xl mb-6 text-center"&gt;
                &lt;p class="text-5xl sm:text-7xl font-bold text-green-400 mb-2" id="chrono-display"&gt;PRÊT: 00&lt;/p&gt;
                &lt;p class="text-xl sm:text-2xl text-purple-300" id="chrono-instruction"&gt;AJOUTEZ DES INTERVALLES&lt;/p&gt;
            &lt;/div&gt;


            &lt;!-- Contrôles du Chrono --&gt;
            &lt;div class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6"&gt;
                &lt;button id="start-chrono-btn" class="btn-retro-green col-span-2 sm:col-span-1"&gt;DÉMARRER&lt;/button&gt;
                &lt;button id="pause-chrono-btn" class="btn-retro-purple col-span-2 sm:col-span-1"&gt;PAUSE&lt;/button&gt;
                &lt;button id="reset-chrono-btn" class="btn-retro-red col-span-2 sm:col-span-1"&gt;RESET&lt;/button&gt;
                &lt;button id="skip-interval-btn" class="btn-retro col-span-2 sm:col-span-1"&gt;PASSER&lt;/button&gt;
            &lt;/div&gt;


            &lt;!-- Paramètres du Chrono --&gt;
            &lt;div class="bg-gray-700 p-4 rounded-lg border-2 border-yellow-500 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3"&gt;PARAMÈTRES :&lt;/h3&gt;
                &lt;div class="mb-4 flex items-center"&gt;
                    &lt;input type="checkbox" id="enable-pre-countdown" ${enableChronoPreCountdown ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /&gt;
                    &lt;label for="enable-pre-countdown" class="text-gray-200 text-sm font-bold"&gt;COMPTE À REBOURS PRÉ-CHRONO&lt;/label&gt;
                &lt;/div&gt;
                &lt;div id="pre-countdown-duration-setting" class="${enableChronoPreCountdown ? '' : 'hidden'} mb-4"&gt;
                    &lt;label for="chrono-pre-countdown-duration" class="block text-gray-200 text-sm font-bold mb-2"&gt;DURÉE PRÉ-COMPTE (SECONDES) :&lt;/label&gt;
                    &lt;input type="number" id="chrono-pre-countdown-duration" value="${chronoPreCountdownDuration}" min="1" class="input-retro" /&gt;
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;!-- Ajout/Modification d'Intervalle --&gt;
            &lt;div class="bg-gray-700 p-4 rounded-lg border-2 border-blue-700 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;AJOUTER / MODIFIER INTERVALLE :&lt;/h3&gt;
                &lt;div class="flex flex-col sm:flex-row gap-4 mb-4"&gt;
                    &lt;div class="flex-1"&gt;
                        &lt;label for="new-duration-minutes" class="block text-gray-200 text-sm font-bold mb-2"&gt;DURÉE (MINUTES) :&lt;/label&gt;
                        &lt;input type="number" id="new-duration-minutes" class="input-retro" placeholder="EX: 1" min="0" value="0" /&gt;
                    &lt;/div&gt;
                    &lt;div class="flex-1"&gt;
                        &lt;label for="new-duration-seconds" class="block text-gray-200 text-sm font-bold mb-2"&gt;DURÉE (SECONDES) :&lt;/label&gt;
                        &lt;input type="number" id="new-duration-seconds" class="input-retro" placeholder="EX: 30" min="0" max="59" value="0" /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="new-instruction" class="block text-gray-200 text-sm font-bold mb-2"&gt;INSTRUCTION :&lt;/label&gt;
                    &lt;input type="text" id="new-instruction" class="input-retro" placeholder="EX: COURSE RAPIDE" /&gt;
                &lt;/div&gt;
                &lt;button id="add-update-interval-btn" class="btn-retro w-full"&gt;AJOUTER&lt;/button&gt;
            &lt;/div&gt;


            &lt;!-- Liste des Intervalles --&gt;
            &lt;div class="bg-gray-700 p-4 rounded-lg border-2 border-purple-500 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;SÉQUENCE D'INTERVALLES :&lt;/h3&gt;
                &lt;p class="text-md sm:text-lg text-gray-300 mb-3"&gt;Durée totale des intervalles : &lt;span class="font-bold text-yellow-300" id="total-interval-duration"&gt;0 minutes&lt;/span&gt;&lt;/p&gt;
                &lt;div id="intervals-list" class="space-y-2 mb-4"&gt;
                    &lt;!-- Les intervalles seront listés ici --&gt;
                &lt;/div&gt;
                &lt;div class="flex flex-col sm:flex-row gap-4"&gt;
                    &lt;input type="text" id="sequenceName" class="input-retro flex-1" placeholder="NOM DE LA SÉQUENCE" /&gt;
                    &lt;button id="save-sequence-btn" class="btn-retro-green"&gt;SAUVEGARDER&lt;/button&gt;
                    &lt;button id="load-sequence-btn" class="btn-retro"&gt;CHARGER&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `;
    container.innerHTML = html;

    // ASSIGNATION DES ÉLÉMENTS AUX VARIABLES GLOBALES DÉCLARÉES EN HAUT DU SCRIPT
    totalDurationDisplayElement = document.getElementById('total-interval-duration');
    intervalsListDiv = document.getElementById('intervals-list');
    newDurationMinutesInput = document.getElementById('new-duration-minutes'); // Mises à jour pour les minutes
    newInstructionInput = document.getElementById('new-instruction');
    addUpdateIntervalBtn = document.getElementById('add-update-interval-btn');

    // Nouvelle variable globale pour le champ des secondes dans le formulaire d'ajout
    newDurationSecondsInput = document.getElementById('new-duration-seconds');


    // Références locales aux éléments de contrôle du chrono
    const chronoDisplay = document.getElementById('chrono-display');
    const chronoInstruction = document.getElementById('chrono-instruction');
    const startChronoBtn = document.getElementById('start-chrono-btn');
    const pauseChronoBtn = document.getElementById('pause-chrono-btn');
    const resetChronoBtn = document.getElementById('reset-chrono-btn');
    const skipIntervalBtn = document.getElementById('skip-interval-btn');
    const enablePreCountdownCheckbox = document.getElementById('enable-pre-countdown');
    const preCountdownDurationSetting = document.getElementById('pre-countdown-duration-setting');
    const chronoPreCountdownDurationInput = document.getElementById('chrono-pre-countdown-duration');
    const saveSequenceBtn = document.getElementById('save-sequence-btn');
    const loadSequenceBtn = document.getElementById('load-sequence-btn');


    // Met à jour l'affichage du chronomètre
    function updateChronoDisplay() {
        const displayTime = chronoCurrentIntervalIndex === -1 ? `PRÊT: ${String(chronoCurrentTime).padStart(2, '0')}` : `${String(Math.floor(chronoCurrentTime / 60)).padStart(2, '0')}:${String(chronoCurrentTime % 60).padStart(2, '0')}`;
        const currentInstruction = chronoCurrentIntervalIndex === -1 ? "PRÉPAREZ-VOUS !" : chronoIntervals[chronoCurrentIntervalIndex]?.instruction || "FINI !";
        chronoDisplay.textContent = displayTime;
        chronoInstruction.textContent = String(currentInstruction).toUpperCase();


        if (isChronoRunning &amp;&amp; !isChronoPaused) {
            startChronoBtn.disabled = true;
            pauseChronoBtn.disabled = false;
            resetChronoBtn.disabled = false;
            skipIntervalBtn.disabled = false;
            startChronoBtn.classList.remove('btn-retro-green');
            startChronoBtn.classList.add('bg-gray-500');
            pauseChronoBtn.classList.remove('bg-gray-500');
            pauseChronoBtn.classList.add('btn-retro-purple');
        } else if (isChronoPaused) {
            startChronoBtn.disabled = false;
            pauseChronoBtn.disabled = true;
            resetChronoBtn.disabled = false;
            skipIntervalBtn.disabled = false;
            startChronoBtn.classList.remove('bg-gray-500');
            startChronoBtn.classList.add('btn-retro-green');
            pauseChronoBtn.classList.remove('btn-retro-purple');
            pauseChronoBtn.classList.add('bg-gray-500');
        } else {
            startChronoBtn.disabled = false;
            pauseChronoBtn.disabled = true;
            resetChronoBtn.disabled = true;
            skipIntervalBtn.disabled = true;
            startChronoBtn.classList.remove('bg-gray-500');
            startChronoBtn.classList.add('btn-retro-green');
            pauseChronoBtn.classList.remove('btn-retro-purple');
            pauseChronoBtn.classList.add('bg-gray-500');
        }
    }


    // Boucle principale du chronomètre
    function chronoLoop() {
        if (!isChronoRunning || isChronoPaused) return;


        if (chronoCurrentIntervalIndex === -1) { // Pre-countdown phase
            chronoCurrentTime--;
            if (chronoCurrentTime &lt;= 0) {
                playMarioKartStartSound();
                chronoCurrentIntervalIndex = 0;
                chronoCurrentTime = chronoIntervals[0].duration;
                speak(String(chronoIntervals[0].instruction).toUpperCase());
                showMessage(String(chronoIntervals[0].instruction).toUpperCase(), 'chrono');
            } else if (chronoCurrentTime &lt;= 3 &amp;&amp; chronoCurrentTime &gt; 0) {
                playBeep(660, 0.1); // Short beep for last 3 seconds
            }
        } else { // Main interval phase
            chronoCurrentTime--;
            if (chronoCurrentTime &lt;= 0) {
                chronoCurrentIntervalIndex++;
                if (chronoCurrentIntervalIndex &lt; chronoIntervals.length) {
                    chronoCurrentTime = chronoIntervals[chronoCurrentIntervalIndex].duration;
                    speak(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase());
                    showMessage(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase(), 'chrono');
                } else {
                    isChronoRunning = false;
                    isChronoPaused = false;
                    chronoCurrentIntervalIndex = -1;
                    chronoCurrentTime = 0;
                    speak("Programme terminé !");
                    showMessage("PROGRAMME TERMINÉ !", 'success');
                    clearInterval(chronoIntervalTimerRef);
                    chronoIntervalTimerRef = null;
                }
            } else if (chronoCurrentTime &lt;= 10 &amp;&amp; chronoCurrentTime &gt; 0) {
                playBeep(880, 0.05); // Short beep for last 10 seconds of an interval
            }
        }
        updateLocalStorageChronoState();
        updateChronoDisplay();
    }

    // Appel des fonctions globales au lieu de les définir localement
    updateTotalIntervalDurationDisplay(); // Appel direct de la fonction globale
    renderIntervalsList(); // Appel direct de la fonction globale


    // Écouteurs d'événements spécifiques à cette vue
    addUpdateIntervalBtn.onclick = () =&gt; {
        const minutes = parseInt(newDurationMinutesInput.value) || 0;
        const seconds = parseInt(newDurationSecondsInput.value) || 0; // Récupère les secondes

        if (minutes === 0 &amp;&amp; seconds === 0) {
            showMessage("ERREUR: LA DURÉE (MINUTES OU SECONDES) EST REQUISE.", 'error');
            return;
        }
        if (newInstructionInput.value.trim() === '') {
            showMessage("ERREUR: L'INSTRUCTION EST REQUISE.", 'error');
            return;
        }

        const totalDurationSeconds = (minutes * 60) + seconds; // Calcule la durée totale

        chronoIntervals.push({ duration: totalDurationSeconds, instruction: newInstructionInput.value.trim() });
        showMessage("INTERVALLE AJOUTÉE !", 'success');

        updateLocalStorageChronoState();
        renderIntervalsList(); // Appel la fonction globale pour rafraîchir
        resetIntervalForm(); // Appel la fonction globale pour effacer les champs
    };

    enablePreCountdownCheckbox.onchange = (e) =&gt; { enableChronoPreCountdown = e.target.checked; preCountdownDurationSetting.classList.toggle('hidden', !enableChronoPreCountdown); updateLocalStorageChronoState(); };
    chronoPreCountdownDurationInput.onchange = (e) =&gt; { chronoPreCountdownDuration = Math.max(1, parseInt(e.target.value) || 1); updateLocalStorageChronoState(); };

    startChronoBtn.onclick = () =&gt; {
        if (chronoIntervals.length === 0) { showMessage("ERREUR: AJOUTEZ DES INTERVALLES AVANT DE COMMENCER.", 'error'); return; }
        if (isChronoRunning &amp;&amp; !isChronoPaused) return; // Already running

        isChronoRunning = true;
        isChronoPaused = false;
        chronoCurrentIntervalIndex = -1; // Reset to pre-countdown state
        if (enableChronoPreCountdown) {
            chronoCurrentTime = chronoPreCountdownDuration;
        } else {
            chronoCurrentIntervalIndex = 0; // Skip pre-countdown
            chronoCurrentTime = chronoIntervals[0].duration;
            speak(String(chronoIntervals[0].instruction).toUpperCase());
            showMessage(String(chronoIntervals[0].instruction).toUpperCase(), 'chrono');
        }
        updateLocalStorageChronoState();
        updateChronoDisplay();
        showMessage("CHRONO DÉMARRÉ !", 'info');
        if (!chronoIntervalTimerRef) {
            chronoIntervalTimerRef = setInterval(chronoLoop, 1000);
        }
    };
    pauseChronoBtn.onclick = () =&gt; {
        isChronoPaused = true;
        updateLocalStorageChronoState();
        updateChronoDisplay();
        showMessage("CHRONO EN PAUSE.", 'info');
        clearInterval(chronoIntervalTimerRef);
        chronoIntervalTimerRef = null;
    };
    resetChronoBtn.onclick = () =&gt; {
        isChronoRunning = false;
        isChronoPaused = false;
        chronoCurrentIntervalIndex = -1;
        chronoCurrentTime = 0;
        updateLocalStorageChronoState();
        updateChronoDisplay();
        showMessage("CHRONO RÉINITIALISÉ.", 'success');
        clearInterval(chronoIntervalTimerRef);
        chronoIntervalTimerRef = null;
    };
    skipIntervalBtn.onclick = () =&gt; {
        if (!isChronoRunning || chronoCurrentIntervalIndex === -1) { showMessage("LE CHRONO N'EST PAS EN COURS OU EN PHASE DE PRÉ-COMPTE.", 'warning'); return; }


        chronoCurrentIntervalIndex++;
        if (chronoCurrentIntervalIndex &lt; chronoIntervals.length) {
            chronoCurrentTime = chronoIntervals[chronoCurrentIntervalIndex].duration;
            speak(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase());
            showMessage(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase(), 'chrono');
        } else {
            // End of sequence
            isChronoRunning = false;
            isChronoPaused = false;
            chronoCurrentIntervalIndex = -1;
            chronoCurrentTime = 0;
            speak("Programme terminé !");
            showMessage("PROGRAMME TERMINÉ !", 'success');
            clearInterval(chronoIntervalTimerRef);
            chronoIntervalTimerRef = null;
        }
        updateLocalStorageChronoState();
        updateChronoDisplay();
    };


    saveSequenceBtn.onclick = () =&gt; {
        const modalDiv = document.createElement('div');
        modalDiv.id = 'save-sequence-modal';
        modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50';
        modalDiv.innerHTML = `
            &lt;div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white"&gt;
                &lt;h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300"&gt;SAUVEGARDER LA SÉQUENCE&lt;/h3&gt;
                &lt;label for="saveSequenceName" class="block text-gray-200 text-sm font-bold mb-2"&gt;NOM :&lt;/label&gt;
                &lt;input type="text" id="saveSequenceName" class="input-retro" placeholder="DONNEZ UN NOM À VOTRE SÉQUENCE" value="${document.getElementById('sequenceName').value}" /&gt;
                &lt;div class="flex justify-end space-x-4 mt-6"&gt;
                    &lt;button id="cancel-save-sequence-btn" class="btn-retro-red"&gt;ANNULER&lt;/button&gt;
                    &lt;button id="confirm-save-sequence-btn" class="btn-retro-green"&gt;SAUVEGARDER&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        `;
        document.getElementById('global-modals-container').appendChild(modalDiv);
        document.getElementById('cancel-save-sequence-btn').onclick = () =&gt; modalDiv.remove();
        document.getElementById('confirm-save-sequence-btn').onclick = () =&gt; {
            const name = document.getElementById('saveSequenceName').value;
            if (!name.trim()) { showMessage("ERREUR: NOM DE LA SÉQUENCE REQUIS.", 'error'); return; }
            if (chronoIntervals.length === 0) { showMessage("ERREUR: AJOUTEZ DES INTERVALLES AVANT DE SAUVEGARDER.", 'error'); return; }
            const newSequence = { id: generateUniqueId(), name: name.trim(), intervals: JSON.stringify(chronoIntervals) };
            intervalSequences.push(newSequence);
            saveToLocalStorage('intervalSequences', intervalSequences);
            showMessage("SUCCÈS: SÉQUENCE ENREGISTRÉE !", 'success');
            modalDiv.remove();
            document.getElementById('sequenceName').value = ''; // Clear sequence name input
        };
    };


    loadSequenceBtn.onclick = () =&gt; {
        const modalDiv = document.createElement('div');
        modalDiv.id = 'load-sequence-modal';
        modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50';
        let sequencesListHtml = '';
        if (intervalSequences.length === 0) sequencesListHtml = '&lt;p class="text-gray-400"&gt;AUCUNE SÉQUENCE ENREGISTRÉE.&lt;/p&gt;';
        else {
            sequencesListHtml = `
                &lt;ul class="space-y-2 max-h-60 overflow-y-auto pr-2"&gt;
                    ${intervalSequences.map(seq =&gt; `
                        &lt;li class="flex justify-between items-center bg-gray-700 p-2 rounded-md border border-gray-600"&gt;
                            &lt;span class="text-gray-100 text-base sm:text-lg"&gt;${String(seq.name).toUpperCase()}&lt;/span&gt;
                            &lt;div&gt;
                                &lt;button class="btn-retro-green text-xs px-2 py-1 mr-2 load-sequence-item-btn" data-id="${seq.id}"&gt;CHARGER&lt;/button&gt;
                                &lt;button class="btn-retro-red text-xs px-2 py-1 delete-sequence-item-btn" data-id="${seq.id}"&gt;SUPPRIMER&lt;/button&gt;
                            &lt;/div&gt;
                        &lt;/li&gt;
                    `).join('')}
                &lt;/ul&gt;
            `;
        }
        modalDiv.innerHTML = `
            &lt;div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-sm text-white"&gt;
                &lt;h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300"&gt;CHARGER LA SÉQUENCE&lt;/h3&gt;
                ${sequencesListHtml}
                &lt;div class="flex justify-end space-x-4 mt-6"&gt;
                    &lt;button id="cancel-load-sequence-btn" class="btn-retro-red"&gt;ANNULER&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        `;
        document.getElementById('global-modals-container').appendChild(modalDiv);
        document.getElementById('cancel-load-sequence-btn').onclick = () =&gt; modalDiv.remove();


        modalDiv.querySelectorAll('.load-sequence-item-btn').forEach(button =&gt; {
            button.onclick = async (event) =&gt; {
                const idToLoad = event.target.dataset.id;
                const sequenceToLoad = intervalSequences.find(seq =&gt; seq.id === idToLoad);
                if (sequenceToLoad) {
                    if (await showConfirmModal("CONFIRMER LE CHARGEMENT DE CETTE SÉQUENCE ? CELA REMPLACERA LA SÉQUENCE ACTUELLE.")) {
                        chronoIntervals = JSON.parse(sequenceToLoad.intervals);
                        updateLocalStorageChronoState();
                        showMessage(`SUCCÈS: SÉQUENCE "${String(sequenceToLoad.name).toUpperCase()}" CHARGÉE !`, 'success');
                        renderIntervalsList();
                        resetIntervalForm();
                        document.getElementById('sequenceName').value = sequenceToLoad.name; // Set loaded sequence name
                        modalDiv.remove();
                    }
                }
            };
        });


        modalDiv.querySelectorAll('.delete-sequence-item-btn').forEach(button =&gt; {
            button.onclick = async (event) =&gt; {
                const idToDelete = event.target.dataset.id;
                if (await showConfirmModal("CONFIRMER LA SUPPRESSION DE CETTE SÉQUENCE ?")) {
                    intervalSequences = intervalSequences.filter(seq =&gt; seq.id !== idToDelete);
                    saveToLocalStorage('intervalSequences', intervalSequences);
                    showMessage("SUCCÈS: SÉQUENCE SUPPRIMÉE !", 'success');
                    modalDiv.remove();
                    loadSequenceBtn.click(); // Re-open load modal to show updated list
                }
            };
        });
    };

    // Appels initiaux
    updateChronoDisplay();
    // Redémarrer le chrono si il était en cours avant le re-rendu de la page
    if (isChronoRunning &amp;&amp; !isChronoPaused &amp;&amp; !chronoIntervalTimerRef) {
        chronoIntervalTimerRef = setInterval(chronoLoop, 1000);
    }
}

    

// Rend la vue de l'évolution (graphiques)
function renderProgressView(container) {
    let html = `
        &lt;div class="card-retro mb-6"&gt;
            &lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;MON ÉVOLUTION&lt;/h2&gt;
            &lt;div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;HISTORIQUE DU POIDS ET IMC :&lt;/h3&gt;
                &lt;div class="relative h-64"&gt;
                    &lt;canvas id="weightChart"&gt;&lt;/canvas&gt;
                &lt;/div&gt;
                &lt;p class="text-xs text-gray-400 mt-2 text-center"&gt;GRAPHIQUE DU POIDS (KG) ET DE L'IMC AU FIL DU TEMPS.&lt;/p&gt;
                &lt;div class="mt-4"&gt;
                    &lt;h4 class="font-semibold text-lg text-yellow-300 mb-2"&gt;DÉTAILS :&lt;/h4&gt;
                    &lt;div id="weight-history-list" class="space-y-2 max-h-48 overflow-y-auto pr-2"&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700"&gt;
                &lt;div class="flex justify-between items-center mb-3"&gt;
                    &lt;h3 class="text-xl sm:text-2xl text-yellow-300"&gt;HISTORIQUE DES ENTRAÎNEMENTS :&lt;/h3&gt;
                    &lt;div class="flex items-center"&gt;
                        &lt;input type="checkbox" id="hideExerciseHistory" ${userProfile.hideExerciseHistory ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /&gt;
                        &lt;label for="hideExerciseHistory" class="text-gray-200 text-sm font-bold"&gt;CACHER&lt;/label&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div id="exercise-history-content" class="${userProfile.hideExerciseHistory ? 'hidden' : ''}"&gt;
                    &lt;div class="mb-4"&gt;
                        &lt;label for="exerciseSelect" class="block text-gray-200 text-sm font-bold mb-2"&gt;SÉLECTIONNER UN EXERCICE :&lt;/label&gt;
                        &lt;select id="exerciseSelect" class="select-retro mb-4"&gt;&lt;/select&gt;
                    &lt;/div&gt;
                    &lt;div class="mb-4"&gt;
                        &lt;h4 class="font-semibold text-lg text-yellow-300 mb-2"&gt;MÉTRIQUES À AFFICHER :&lt;/h4&gt;
                        &lt;div class="flex flex-wrap gap-2"&gt;
                            &lt;label class="inline-flex items-center"&gt;
                                &lt;input type="checkbox" name="metric-checkbox" value="reps" class="form-checkbox h-4 w-4 text-blue-600 rounded" checked&gt;
                                &lt;span class="ml-2 text-gray-200 text-sm"&gt;Répétitions / Durée&lt;/span&gt;
                            &lt;/label&gt;
                            &lt;label class="inline-flex items-center"&gt;
                                &lt;input type="checkbox" name="metric-checkbox" value="sets" class="form-checkbox h-4 w-4 text-green-600 rounded"&gt;
                                &lt;span class="ml-2 text-gray-200 text-sm"&gt;Séries / Rounds&lt;/span&gt;
                            &lt;/label&gt;
                            &lt;label class="inline-flex items-center"&gt;
                                &lt;input type="checkbox" name="metric-checkbox" value="weight" class="form-checkbox h-4 w-4 text-purple-600 rounded"&gt;
                                &lt;span class="ml-2 text-gray-200 text-sm"&gt;Poids&lt;/span&gt;
                            &lt;/label&gt;
                            &lt;label class="inline-flex items-center"&gt;
                                &lt;input type="checkbox" name="metric-checkbox" value="volume" class="form-checkbox h-4 w-4 text-red-600 rounded"&gt;
                                &lt;span class="ml-2 text-gray-200 text-sm"&gt;Volume&lt;/span&gt;
                            &lt;/label&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="relative h-64 mb-4"&gt;
                        &lt;canvas id="exerciseChart"&gt;&lt;/canvas&gt;
                    &lt;/div&gt;
                    &lt;p class="text-xs text-gray-400 mt-2 text-center"&gt;GRAPHIQUE DE LA PROGRESSION DE L'EXERCICE SELON LES MÉTRIQUES SÉLECTIONNÉES.&lt;/p&gt;
                    &lt;div class="mt-4"&gt;
                        &lt;h4 class="font-semibold text-lg text-yellow-300 mb-2"&gt;DÉTAILS :&lt;/h4&gt;
                        &lt;div id="exercise-history-list" class="space-y-2 max-h-48 overflow-y-auto pr-2"&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `;
    container.innerHTML = html;

    // Fonction utilitaire pour découper un long texte en plusieurs lignes pour l'affichage
    // Cette fonction est déplacée ici pour être auto-contenue dans la vue
    // Version améliorée pour mieux s'adapter aux écrans étroits (ex: mobiles)
    function splitTextIntoLines(text, maxLength = 30) { // Réduction de la longueur maximale par ligne à 30
        if (!text) return [];
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';

        for (const word of words) {
            // Si ajouter le mot actuel dépasse la longueur maximale ET qu'il y a déjà du texte sur la ligne
            // OU si le mot lui-même est plus long que la longueur maximale
            if ((currentLine.length + word.length + 1 &gt; maxLength &amp;&amp; currentLine.length &gt; 0) || word.length &gt; maxLength) {
                if (currentLine.length &gt; 0) {
                    lines.push(currentLine.trim());
                }
                // Si le mot lui-même est trop long, le découper
                if (word.length &gt; maxLength) {
                    let tempWord = word;
                    while (tempWord.length &gt; maxLength) {
                        lines.push(tempWord.substring(0, maxLength));
                        tempWord = tempWord.substring(maxLength);
                    }
                    currentLine = tempWord + ' '; // La partie restante du mot commence une nouvelle ligne
                } else {
                    currentLine = word + ' ';
                }
            } else {
                currentLine += word + ' ';
            }
        }
        if (currentLine.length &gt; 0) {
            lines.push(currentLine.trim());
        }
        return lines;
    }

    // Weight Chart
    const weightCtx = document.getElementById('weightChart').getContext('2d');
    const sortedWeightHistory = [...weightHistory].sort((a, b) =&gt; new Date(a.date).getTime() - new Date(b.date).getTime());
    const weightLabels = sortedWeightHistory.map(entry =&gt; new Date(entry.date).toLocaleDateString('fr-FR', { month: 'short', day: 'numeric' }));
    const weights = sortedWeightHistory.map(entry =&gt; entry.weight);
    const imcs = sortedWeightHistory.map(entry =&gt; entry.imc);

    weightChartInstance = new Chart(weightCtx, {
        type: 'line',
        data: {
            labels: weightLabels,
            datasets: [{
                label: 'POIDS (KG)',
                data: weights,
                borderColor: '#fcd34d',
                backgroundColor: 'rgba(252, 211, 77, 0.2)',
                tension: 0.4,
                fill: true
            }, {
                label: 'IMC',
                data: imcs,
                borderColor: '#a78bfa',
                backgroundColor: 'rgba(167, 139, 250, 0.2)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: 'white', font: { family: 'VT323' } } },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) label += ': ';
                            if (context.parsed.y !== null) label += context.parsed.y;
                            if (context.dataset.label === 'POIDS (KG)') label += ' KG';
                            return label;
                        }
                    },
                    titleFont: { family: 'VT323' },
                    bodyFont: { family: 'VT323' }
                }
            },
            scales: {
                x: { ticks: { color: 'white', font: { family: 'VT323' } }, grid: { color: 'rgba(255,255,255,0.1)' } },
                y: { ticks: { color: 'white', font: { family: 'VT323' } }, grid: { color: 'rgba(255,255,255,0.1)' } }
            }
        }
    });

    // Weight History List
    const weightHistoryListDiv = document.getElementById('weight-history-list');
    if (sortedWeightHistory.length === 0) { weightHistoryListDiv.innerHTML = '&lt;p class="text-gray-400"&gt;AUCUN HISTORIQUE DE POIDS ENREGISTRÉ.&lt;/p&gt;'; }
    else {
        let weightListHtml = `&lt;ul class="space-y-1"&gt;`;
        // Display in reverse chronological order (most recent first)
        [...sortedWeightHistory].reverse().forEach(entry =&gt; {
            const date = new Date(entry.date).toLocaleDateString('fr-FR', { year: 'numeric', month: 'long', day: 'numeric' });
            weightListHtml += `&lt;li class="text-sm text-gray-300"&gt;**${date.toUpperCase()} :** POIDS: ${entry.weight} KG, IMC: ${entry.imc} (${String(entry.imcCategory).toUpperCase()})&lt;/li&gt;`;
        });
        weightListHtml += `&lt;/ul&gt;`;
        weightHistoryListDiv.innerHTML = weightListHtml;
    }

    // Exercise History
    const hideExerciseHistoryCheckbox = document.getElementById('hideExerciseHistory');
    const exerciseHistoryContent = document.getElementById('exercise-history-content');
    const exerciseSelect = document.getElementById('exerciseSelect');
    const metricCheckboxes = document.querySelectorAll('input[name="metric-checkbox"]');
    const exerciseHistoryListDiv = document.getElementById('exercise-history-list');

    hideExerciseHistoryCheckbox.onchange = (e) =&gt; {
        userProfile.hideExerciseHistory = e.target.checked;
        saveToLocalStorage('userProfile', userProfile);
        exerciseHistoryContent.classList.toggle('hidden', userProfile.hideExerciseHistory);
        if (!userProfile.hideExerciseHistory) renderExerciseChart(); // Re-render chart if shown
    };

    // Populate exercise select dropdown
    const uniqueExerciseNames = [...new Set(workoutLogs.map(log =&gt; log.exerciseName))];
    exerciseSelect.innerHTML = `&lt;option value=""&gt;SÉLECTIONNER UN EXERCICE&lt;/option&gt;` +
                               uniqueExerciseNames.map(name =&gt; `&lt;option value="${name}"&gt;${String(name).toUpperCase()}&lt;/option&gt;`).join('');

    exerciseSelect.onchange = renderExerciseChart;
    metricCheckboxes.forEach(checkbox =&gt; {
        checkbox.onchange = renderExerciseChart;
    });

    function parseRepsAndSets(log) {
        let parsedReps = parseFloat(log.reps) || 0;
        let parsedSets = parseFloat(log.sets) || 0;
        let durationInSeconds = 0;

        // Handle duration in reps
        if (typeof log.reps === 'string' &amp;&amp; log.reps.toUpperCase().includes('MIN')) {
            const match = log.reps.match(/(\d+)\s*MIN/i);
            if (match) {
                durationInSeconds = parseInt(match[1]) * 60;
                parsedReps = durationInSeconds; // Store duration in seconds for volume calculation
            }
        } else if (typeof log.reps === 'string' &amp;&amp; log.reps.toUpperCase().includes('SECONDES')) {
             const match = log.reps.match(/(\d+)\s*SECONDES/i);
            if (match) {
                durationInSeconds = parseInt(match[1]);
                parsedReps = durationInSeconds;
            }
        }

        // Handle sets that might be like "3 ROUNDS"
        if (typeof log.sets === 'string' &amp;&amp; log.sets.toUpperCase().includes('ROUND')) {
            const match = log.sets.match(/(\d+)\s*ROUND/i);
            if (match) {
                parsedSets = parseInt(match[1]);
            }
        }

        return { parsedReps, parsedSets, durationInSeconds };
    }

    function getExerciseChartData() {
        const selectedExercise = exerciseSelect.value;
        if (!selectedExercise) return { labels: [], datasets: [] };

        const filteredLogs = workoutLogs
            .filter(log =&gt; log.exerciseName === selectedExercise)
            .sort((a, b) =&gt; new Date(a.date).getTime() - new Date(b.date).getTime());

        const chartLabels = filteredLogs.map(log =&gt; new Date(log.date).toLocaleDateString('fr-FR', { month: 'short', day: 'numeric' }));
        const datasets = [];

        const selectedMetrics = Array.from(metricCheckboxes)
                                    .filter(checkbox =&gt; checkbox.checked)
                                    .map(checkbox =&gt; checkbox.value);

        const colors = {
            'reps': { borderColor: '#3b82f6', backgroundColor: 'rgba(59, 130, 246, 0.2)' }, // blue
            'sets': { borderColor: '#22c55e', backgroundColor: 'rgba(34, 197, 94, 0.2)' }, // green
            'weight': { borderColor: '#9333ea', backgroundColor: 'rgba(147, 51, 234, 0.2)' }, // purple
            'volume': { borderColor: '#ef4444', backgroundColor: 'rgba(239, 68, 68, 0.2)' } // red
        };

        selectedMetrics.forEach(metric =&gt; {
            let data = [];
            let label = '';
            let unit = '';

            switch (metric) {
                case 'reps':
                    data = filteredLogs.map(log =&gt; {
                        const { parsedReps } = parseRepsAndSets(log);
                        return parsedReps;
                    });
                    label = 'RÉPÉTITIONS / DURÉE';
                    unit = ''; // Unit varies, handled in tooltip
                    break;
                case 'sets':
                    data = filteredLogs.map(log =&gt; {
                        const { parsedSets } = parseRepsAndSets(log);
                        return parsedSets;
                    });
                    label = 'SÉRIES / ROUNDS';
                    unit = ''; // Unit varies, handled in tooltip
                    break;
                case 'weight':
                    data = filteredLogs.map(log =&gt; parseFloat(log.weight) || 0);
                    label = 'POIDS';
                    unit = ' KG';
                    break;
                case 'volume':
                    data = filteredLogs.map(log =&gt; {
                        const { parsedReps, parsedSets } = parseRepsAndSets(log);
                        const weightVal = parseFloat(log.weight) || 1; // Assume 1 if no weight (bodyweight)
                        return parsedSets * parsedReps * weightVal;
                    });
                    label = 'VOLUME';
                    unit = ''; // Unit varies, handled in tooltip
                    break;
            }

            datasets.push({
                label: label,
                data: data,
                borderColor: colors[metric].borderColor,
                backgroundColor: colors[metric].backgroundColor,
                tension: 0.4,
                fill: false, // Set to false for multiple lines
                pointRadius: 5,
                pointHoverRadius: 8,
                pointBackgroundColor: colors[metric].borderColor,
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                metricType: metric // Custom property to help tooltip
            });
        });

        return { labels: chartLabels, datasets: datasets, filteredLogs: filteredLogs };
    }

    function renderExerciseChart() {
        if (exerciseChartInstance) { exerciseChartInstance.destroy(); exerciseChartInstance = null; }

        const { labels, datasets, filteredLogs } = getExerciseChartData();
        const exerciseCtx = document.getElementById('exerciseChart').getContext('2d');

        if (datasets.length === 0 || labels.length === 0) {
            exerciseCtx.clearRect(0, 0, exerciseCtx.canvas.width, exerciseCtx.canvas.height);
            showMessage("PAS ASSEZ DE DONNÉES POUR L'EXERCICE SÉLECTIONNÉ OU AUCUNE MÉTRIQUE CHOISIE.", 'info');
            return;
        }

        exerciseChartInstance = new Chart(exerciseCtx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { labels: { color: 'white', font: { family: 'VT323' } } },
                    tooltip: {
                        // Ajout de 'displayColors: false' pour libérer de l'espace horizontal
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                return new Date(filteredLogs[context[0].dataIndex].date).toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }).toUpperCase();
                            },
                            label: function(context) {
                                const log = filteredLogs[context.dataIndex];
                                const metricType = context.dataset.metricType;
                                let value = context.parsed.y;
                                let label = context.dataset.label || '';

                                if (label) label += ': ';

                                switch (metricType) {
                                    case 'reps':
                                        return `${label}${log.reps}`;
                                    case 'sets':
                                        return `${label}${log.sets}`;
                                    case 'weight':
                                        return `${label}${value} KG`;
                                    case 'volume':
                                        return `${label}${value} (UNITÉS)`;
                                    default:
                                        return `${label}${value}`;
                                }
                            },
                            afterBody: function(context) {
                                const log = filteredLogs[context[0].dataIndex];
                                let details = [];
                                details.push(`RESSENTI: ${String(log.feeling).toUpperCase()}`);
                                if (log.notes) {
                                    // Utilise la fonction pour découper les notes avec une longueur de ligne réduite
                                    const noteLines = splitTextIntoLines(`NOTES: ${String(log.notes).toUpperCase()}`, 30); // Longueur maximale réduite à 30
                                    noteLines.forEach(line =&gt; details.push(line));
                                }
                                return details;
                            }
                        },
                        titleFont: { family: 'VT323' },
                        bodyFont: { family: 'VT323' }
                    }
                },
                scales: {
                    x: { ticks: { color: 'white', font: { family: 'VT323' } }, grid: { color: 'rgba(255,255,255,0.1)' } },
                    y: { beginAtZero: true, ticks: { color: 'white', font: { family: 'VT323' } }, grid: { color: 'rgba(255,255,255,0.1)' } }
                }
            }
        });
    }

    // Exercise History List (detailed log below chart)
    function renderDetailedExerciseHistoryList() {
        exerciseHistoryListDiv.innerHTML = '';
        if (workoutLogs.length === 0) {
            exerciseHistoryListDiv.innerHTML = '&lt;p class="text-gray-400"&gt;AUCUN ENTRAÎNEMENT ENREGISTRÉ.&lt;/p&gt;';
            return;
        }

        let exerciseListHtml = `&lt;ul class="space-y-1"&gt;`;
        // Display in reverse chronological order (most recent first)
        [...workoutLogs].reverse().forEach(log =&gt; {
            const date = new Date(log.date).toLocaleDateString('fr-FR', { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' });
            exerciseListHtml += `&lt;li class="text-sm text-gray-300"&gt;**${date.toUpperCase()} :** ${String(log.exerciseName).toUpperCase()} (${String(log.sets).toUpperCase()} SÉRIES, ${String(log.reps).toUpperCase()}${log.weight ? `, ${log.weight} KG` : ''}) - RESSENTI: ${String(log.feeling).toUpperCase()}${log.notes ? ` - NOTES: ${String(log.notes).toUpperCase()}` : ''}&lt;/li&gt;`;
        });
        exerciseListHtml += `&lt;/ul&gt;`;
        exerciseHistoryListDiv.innerHTML = exerciseListHtml;
    }


    renderDetailedExerciseHistoryList(); // Render the list initially
    // Render chart initially if not hidden and an exercise is selected
    if (!userProfile.hideExerciseHistory &amp;&amp; uniqueExerciseNames.length &gt; 0) {
        exerciseSelect.value = uniqueExerciseNames[0]; // Select the first exercise by default
        renderExerciseChart();
    } else if (!userProfile.hideExerciseHistory &amp;&amp; uniqueExerciseNames.length === 0) {
        showMessage("PAS ASSEZ DE DONNÉES D'EXERCICES POUR LE GRAPHIQUE. ENREGISTREZ DES SÉANCES.", 'info');
    }
}


// Rend la vue de la salle des trophées
function renderTrophyRoomView(container) {
    let html = `
        &lt;div class="card-retro mb-6"&gt;
            &lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;SALLE DES TROPHÉES&lt;/h2&gt;
            &lt;div id="trophies-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"&gt;&lt;/div&gt;
        &lt;/div&gt;
    `;
    container.innerHTML = html;

    const trophiesGrid = document.getElementById('trophies-grid');
    // Filter to only show earned trophies
    const earnedTrophiesData = userProfile.earnedTrophies.map(earned =&gt; {
        return allTrophies.find(t =&gt; t.id === earned.id);
    }).filter(Boolean); // Filter out any undefined if an ID doesn't match

    const sortedEarnedTrophies = [...earnedTrophiesData].sort((a, b) =&gt; a.levelRequired - b.levelRequired);

    if (sortedEarnedTrophies.length === 0) {
        trophiesGrid.innerHTML = '&lt;p class="text-gray-400 text-center col-span-full"&gt;AUCUN TROPHÉE DÉBLOQUÉ POUR LE MOMENT. CONTINUEZ À VOUS ENTRAÎNER POUR EN GAGNER !&lt;/p&gt;';
    } else {
        sortedEarnedTrophies.forEach(trophy =&gt; {
            const earnedInfo = userProfile.earnedTrophies.find(t =&gt; t.id === trophy.id); // Get the timestamp from earnedTrophies
            const trophyDiv = document.createElement('div');
            trophyDiv.className = `p-4 rounded-lg border-4 border-yellow-500 bg-yellow-900 shadow-lg text-center`;
            trophyDiv.innerHTML = `
                &lt;i data-lucide="trophy" class="text-6xl text-yellow-300 mb-2"&gt;&lt;/i&gt;
                &lt;h3 class="text-xl font-bold text-yellow-200"&gt;${String(trophy.name).toUpperCase()}&lt;/h3&gt;
                &lt;p class="text-sm text-gray-100"&gt;${String(trophy.description).toUpperCase()}&lt;/p&gt;
                &lt;p class="text-xs mt-2 text-green-300"&gt;NIVEAU REQUIS : ${trophy.levelRequired}&lt;/p&gt;
                ${earnedInfo ? `&lt;p class="text-xs text-green-400 mt-1"&gt;DÉBLOQUÉ LE : ${new Date(earnedInfo.timestamp).toLocaleDateString('fr-FR')}&lt;/p&gt;` : ''}
            `;
            trophiesGrid.appendChild(trophyDiv);
        });
    }
    renderLucideIcons(); // Ensure Lucide icons are rendered
}
// Rend la vue du calendrier d'objectifs sportifs
function renderCalendarView(container) {
    let html = `
        &lt;div class="card-retro mb-6"&gt;
            &lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;CALENDRIER D'OBJECTIFS&lt;/h2&gt;

            &lt;div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;PARAMÈTRES DU PROGRAMME :&lt;/h3&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="programStartDate" class="block text-gray-200 text-sm font-bold mb-2"&gt;DATE DE DÉBUT DU PROGRAMME :&lt;/label&gt;
                    &lt;input type="date" id="programStartDate" class="input-retro" value="${sportProgramCalendar.startDate}" /&gt;
                &lt;/div&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="totalProgramWeeksInput" class="block text-gray-200 text-sm font-bold mb-2"&gt;DURÉE TOTALE DU PROGRAMME (SEMAINES) :&lt;/label&gt;
                    &lt;input type="number" id="totalProgramWeeksInput" class="input-retro" min="1" value="${totalProgramWeeks}" /&gt;
                &lt;/div&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="currentProgramPhaseSelect" class="block text-gray-200 text-sm font-bold mb-2"&gt;PHASE ACTUELLE :&lt;/label&gt;
                    &lt;select id="currentProgramPhaseSelect" class="select-retro"&gt;
                        &lt;option value="phase1"&gt;PHASE 1 : ${String(workoutProgram.phase1?.name || 'INITIAL').toUpperCase()}&lt;/option&gt;
                        &lt;option value="phase2"&gt;PHASE 2 : ${String(workoutProgram.phase2?.name || 'ALTERNATIVE').toUpperCase()}&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                 &lt;button id="save-calendar-settings-btn" class="btn-retro-green w-full"&gt;SAUVEGARDER LES PARAMÈTRES&lt;/button&gt;
                 &lt;p class="text-xs text-gray-400 mt-2 text-center"&gt;CHANGEZ LA DATE DE DÉBUT POUR RÉINITIALISER LE CALENDRIER.&lt;/p&gt;
            &lt;/div&gt;

            &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;VOTRE CALENDRIER :&lt;/h3&gt;
                &lt;div id="calendar-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"&gt;
                    &lt;!-- Les semaines du calendrier seront générées ici --&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `;
    container.innerHTML = html;

    const programStartDateInput = document.getElementById('programStartDate');
    const totalProgramWeeksInput = document.getElementById('totalProgramWeeksInput');
    const currentProgramPhaseSelect = document.getElementById('currentProgramPhaseSelect');
    const saveCalendarSettingsBtn = document.getElementById('save-calendar-settings-btn');
    const calendarGrid = document.getElementById('calendar-grid');

    // Initialisation des valeurs
    programStartDateInput.value = sportProgramCalendar.startDate;
    totalProgramWeeksInput.value = totalProgramWeeks;
    currentProgramPhaseSelect.value = currentProgramPhase;

    // Fonction pour sauvegarder les paramètres du calendrier
    saveCalendarSettingsBtn.onclick = () =&gt; {
        const newStartDate = programStartDateInput.value;
        const newTotalWeeks = parseInt(totalProgramWeeksInput.value);
        const newCurrentPhase = currentProgramPhaseSelect.value;

        if (!newStartDate || isNaN(newTotalWeeks) || newTotalWeeks &lt; 1) {
            showMessage("ERREUR: VEUILLEZ RENSEIGNER UNE DATE DE DÉBUT ET UNE DURÉE VALIDES.", 'error');
            return;
        }

        // Si la date de début change, réinitialiser l'historique des semaines
        if (newStartDate !== sportProgramCalendar.startDate) {
            sportProgramCalendar.startDate = newStartDate;
            sportProgramCalendar.weeks = {}; // Réinitialise les semaines
            showMessage("DATE DE DÉBUT MISE À JOUR. CALENDRIER RÉINITIALISÉ.", 'info');
        }

        totalProgramWeeks = newTotalWeeks;
        currentProgramPhase = newCurrentPhase;

        saveToLocalStorage('sportProgramCalendar', sportProgramCalendar);
        saveToLocalStorage('totalProgramWeeks', totalProgramWeeks);
        saveToLocalStorage('currentProgramPhase', currentProgramPhase);

        showMessage("PARAMÈTRES DU CALENDRIER SAUVEGARDÉS !", 'success');
        renderCalendarWeeks(); // Re-render le calendrier après sauvegarde
    };


    // Fonction pour générer et afficher les semaines du calendrier
    function renderCalendarWeeks() {
        calendarGrid.innerHTML = '';
        const startDate = new Date(sportProgramCalendar.startDate);

        for (let i = 0; i &lt; totalProgramWeeks; i++) {
            const weekStartDate = new Date(startDate);
            weekStartDate.setDate(startDate.getDate() + (i * 7));
            const weekEndDate = new Date(weekStartDate);
            weekEndDate.setDate(weekStartDate.getDate() + 6);

            const weekKey = formatDateToYYYYMMDD(weekStartDate);
            const weekData = sportProgramCalendar.weeks[weekKey] || { completed: false, sessions: 0, phase: 'phase1' };

            // Déterminer la phase de la semaine
            let phaseName = 'PHASE INCONNUE';
            if (workoutProgram.phase1 &amp;&amp; i &lt; 6) { // Supposons 6 semaines par phase pour l'exemple
                phaseName = workoutProgram.phase1.name;
                weekData.phase = 'phase1';
            } else if (workoutProgram.phase2 &amp;&amp; i &gt;= 6 &amp;&amp; i &lt; 12) {
                phaseName = workoutProgram.phase2.name;
                weekData.phase = 'phase2';
            } else {
                // Si plus de 12 semaines ou phases supplémentaires, la logique devrait être affinée
                // Pour cet exemple, on reste sur phase1/phase2
                phaseName = workoutProgram.phase1.name; // Fallback
                weekData.phase = 'phase1'; // Fallback
            }


            const weekDiv = document.createElement('div');
            weekDiv.className = `p-4 rounded-lg border-4 shadow-lg text-center ${weekData.completed ? 'border-green-500 bg-green-900' : 'border-blue-500 bg-gray-800'}`;
            weekDiv.innerHTML = `
                &lt;h3 class="text-xl font-bold ${weekData.completed ? 'text-green-200' : 'text-blue-200'}"&gt;SEMAINE ${i + 1}&lt;/h3&gt;
                &lt;p class="text-sm text-gray-300 mb-2"&gt;${formatDateToYYYYMMDD(weekStartDate)} au ${formatDateToYYYYMMDD(weekEndDate)}&lt;/p&gt;
                &lt;p class="text-yellow-300 text-sm mb-3"&gt;PHASE : ${String(phaseName).toUpperCase()}&lt;/p&gt;

                &lt;div class="flex items-center justify-center mb-3"&gt;
                    &lt;input type="checkbox" id="week-completed-${weekKey}" data-week-key="${weekKey}"
                        class="mr-2 h-5 w-5 text-purple-600 rounded border-gray-300 focus:ring-purple-500 cursor-pointer"
                        ${weekData.completed ? 'checked' : ''}&gt;
                    &lt;label for="week-completed-${weekKey}" class="text-gray-200 text-sm font-bold cursor-pointer"&gt;SEMAINE TERMINÉE&lt;/label&gt;
                &lt;/div&gt;

                &lt;div class="mb-3"&gt;
                    &lt;label for="sessions-count-${weekKey}" class="block text-gray-200 text-sm font-bold mb-2"&gt;SÉANCES FAITES :&lt;/label&gt;
                    &lt;input type="number" id="sessions-count-${weekKey}" data-week-key="${weekKey}"
                        class="input-retro text-center w-20 mx-auto" min="0" value="${weekData.sessions}" /&gt;
                &lt;/div&gt;
            `;
            calendarGrid.appendChild(weekDiv);

            // Attach listeners
            const checkbox = weekDiv.querySelector(`#week-completed-${weekKey}`);
            checkbox.onchange = (e) =&gt; {
                const isCompleted = e.target.checked;
                const weekToUpdateKey = e.target.dataset.weekKey;
                if (!sportProgramCalendar.weeks[weekToUpdateKey]) {
                    sportProgramCalendar.weeks[weekToUpdateKey] = { completed: false, sessions: 0, phase: weekData.phase };
                }
                sportProgramCalendar.weeks[weekToUpdateKey].completed = isCompleted;

                if (isCompleted) {
                    userProfile.currentXP += xpPerWeekCompleted;
                    showMessage(`XP GAGNÉE : ${xpPerWeekCompleted} XP POUR LA SEMAINE TERMINÉE !`, 'success');
                    updateXPBar();
                } else {
                    // Optionnel: retirer l'XP si la case est décochée (peut être annulé si l'XP est permanente)
                    userProfile.currentXP = Math.max(0, userProfile.currentXP - xpPerWeekCompleted);
                    showMessage(`XP RETIRÉE : ${xpPerWeekCompleted} XP POUR LA SEMAINE DÉCOCHÉE.`, 'warning');
                    updateXPBar();
                }
                saveToLocalStorage('sportProgramCalendar', sportProgramCalendar);
                saveToLocalStorage('userProfile', userProfile);
                renderCalendarWeeks(); // Re-render pour mettre à jour les couleurs
            };

            const sessionsInput = weekDiv.querySelector(`#sessions-count-${weekKey}`);
            sessionsInput.onchange = (e) =&gt; {
                const sessions = parseInt(e.target.value) || 0;
                const weekToUpdateKey = e.target.dataset.weekKey;
                if (!sportProgramCalendar.weeks[weekToUpdateKey]) {
                    sportProgramCalendar.weeks[weekToUpdateKey] = { completed: false, sessions: 0, phase: weekData.phase };
                }
                sportProgramCalendar.weeks[weekToUpdateKey].sessions = sessions;
                saveToLocalStorage('sportProgramCalendar', sportProgramCalendar);
            };
        }
        renderLucideIcons();
    }

    // Appel initial pour afficher le calendrier
    renderCalendarWeeks();
}
// Rend la vue des options
function renderOptionsView(container) {
    let html = `
        &lt;div class="card-retro mb-6"&gt;
            &lt;h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center"&gt;OPTIONS&lt;/h2&gt;

            &lt;div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;PARAMÈTRES AUDIO :&lt;/h3&gt;
                &lt;div class="flex items-center mb-4"&gt;
                    &lt;input type="checkbox" id="toggle-audio" ${isAudioActive ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /&gt;
                    &lt;label for="toggle-audio" class="text-gray-200 text-sm font-bold"&gt;ACTIVER LE SON ET LA SYNTHÈSE VOCALE&lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="master-volume" class="block text-gray-200 text-sm font-bold mb-2"&gt;VOLUME PRINCIPAL :&lt;/label&gt;
                    &lt;input type="range" id="master-volume" min="0" max="1" step="0.01" value="${masterVolume}" class="w-full" /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
&lt;div class="p-4 rounded-lg border-2 border-yellow-500 bg-gray-700 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;PROGRAMME NUTRITIONNEL ET SPORTIF :&lt;/h3&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="nutritional-program-text" class="block text-gray-200 text-sm font-bold mb-2"&gt;TEXTE DU PROGRAMME NUTRITIONNEL :&lt;/label&gt;
                    &lt;textarea id="nutritional-program-text" class="input-retro h-48" placeholder="Collez votre nouveau programme nutritionnel ici (texte brut)..."&gt;${userProfile.customNutritionalProgramText || nutritionalProgramText}&lt;/textarea&gt;
                    &lt;p class="text-xs text-gray-400 mt-1"&gt;CE TEXTE SERA UTILISÉ PAR L'IA POUR GÉNÉRER VOS RECETTES.&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="workout-program-json" class="block text-gray-200 text-sm font-bold mb-2"&gt;PROGRAMME SPORTIF (FORMAT JSON) :&lt;/label&gt;
                    &lt;textarea id="workout-program-json" class="input-retro h-48" placeholder="Collez votre nouveau programme sportif au format JSON ici..."&gt;${userProfile.customWorkoutProgramJSON || JSON.stringify(defaultWorkoutProgramStructure, null, 2)}&lt;/textarea&gt;
                    &lt;p class="text-xs text-gray-400 mt-1"&gt;DOIT ÊTRE UN JSON VALIDE. L'IA UTILISERA CE PROGRAMME POUR L'ONGLET SPORT.&lt;/p&gt;
                &lt;/div&gt;
                &lt;button id="save-programs-btn" class="btn-retro-green w-full mb-4"&gt;SAUVEGARDER LES PROGRAMMES&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mb-6"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;GESTION DES DONNÉES :&lt;/h3&gt;
                &lt;div class="mb-4"&gt;
                    &lt;label for="api-key-input" class="block text-gray-200 text-sm font-bold mb-2"&gt;CLÉ API (POUR GÉNÉRATION DE RECETTES) :&lt;/label&gt;
                    &lt;input type="password" id="api-key-input" class="input-retro" placeholder="ENTREZ VOTRE CLÉ API ICI" value="${userProfile.apiKey || ''}" /&gt;
                    &lt;p class="text-xs text-gray-400 mt-1"&gt;NÉCESSAIRE POUR LA GÉNÉRATION DE RECETTES PAR L'IA. VOTRE CLÉ EST STOCKÉE LOCALEMENT.&lt;/p&gt;
                &lt;/div&gt;
                &lt;button id="save-api-key-btn" class="btn-retro-green w-full mb-4"&gt;SAUVEGARDER CLÉ API&lt;/button&gt;
                &lt;button id="export-data-btn" class="btn-retro w-full mb-4"&gt;EXPORTER MES DONNÉES&lt;/button&gt;
                &lt;button id="import-data-btn" class="btn-retro w-full mb-4"&gt;IMPORTER MES DONNÉES&lt;/button&gt;
                &lt;input type="file" id="import-file-input" accept=".json" class="hidden" /&gt;
                &lt;button id="reset-all-data-btn" class="btn-retro-red w-full"&gt;RÉINITIALISER TOUTES LES DONNÉES&lt;/button&gt;
            &lt;/div&gt;

            &lt;div class="p-4 rounded-lg border-2 border-yellow-500 bg-gray-700"&gt;
                &lt;h3 class="text-xl sm:text-2xl text-yellow-300 mb-3"&gt;À PROPOS :&lt;/h3&gt;
                &lt;p class="text-gray-300 text-sm mb-2"&gt;FITQUEST V1.0&lt;/p&gt;
                &lt;p class="text-gray-300 text-sm"&gt;DÉVELOPPÉ PAR WAEKY&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    `;
    container.innerHTML = html;

    const toggleAudioCheckbox = document.getElementById('toggle-audio');
    const masterVolumeSlider = document.getElementById('master-volume');
    const apiKeyInput = document.getElementById('api-key-input');
    const saveApiKeyBtn = document.getElementById('save-api-key-btn');
    const exportDataBtn = document.getElementById('export-data-btn');
    const importDataBtn = document.getElementById('import-data-btn');
    const importFileInput = document.getElementById('import-file-input');
    const resetAllDataBtn = document.getElementById('reset-all-data-btn');
    const nutritionalProgramTextInput = document.getElementById('nutritional-program-text');
    const workoutProgramJsonInput = document.getElementById('workout-program-json');
    const saveProgramsBtn = document.getElementById('save-programs-btn');

    saveProgramsBtn.onclick = () =&gt; {
        const newNutritionalText = nutritionalProgramTextInput.value.trim();
        const newWorkoutJson = workoutProgramJsonInput.value.trim();

        let isValidWorkoutJson = true;
        if (newWorkoutJson) {
            try {
                JSON.parse(newWorkoutJson);
            } catch (e) {
                isValidWorkoutJson = false;
                showMessage("ERREUR: LE PROGRAMME SPORTIF N'EST PAS UN JSON VALIDE. VEUILLEZ CORRIGER.", 'error');
                return;
            }
        }

        userProfile.customNutritionalProgramText = newNutritionalText;
        userProfile.customWorkoutProgramJSON = newWorkoutJson;
        saveToLocalStorage('userProfile', userProfile);

        // Recharger les programmes pour que les changements soient appliqués immédiatement
        nutritionalProgramText = userProfile.customNutritionalProgramText || nutritionalProgramText;
        try {
            workoutProgram = userProfile.customWorkoutProgramJSON ? JSON.parse(userProfile.customWorkoutProgramJSON) : JSON.parse(JSON.stringify(defaultWorkoutProgramStructure));
        } catch (e) {
            console.error("Erreur lors du parsing du programme sportif personnalisé après sauvegarde, chargement du programme par défaut.", e);
            showMessage("ERREUR: PROGRAMME SPORTIF PERSONNALISÉ CORROMPU APRÈS SAUVEGARDE. CHARGEMENT DU PROGRAMME PAR DÉFAUT.", 'error');
            workoutProgram = JSON.parse(JSON.stringify(defaultWorkoutProgramStructure));
        }

        showMessage("PROGRAMMES MIS À JOUR AVEC SUCCÈS !", 'success');
        // Re-render the current page to reflect changes, especially in 'Sport' tab
        renderPage(currentPage);
    };
    toggleAudioCheckbox.checked = isAudioActive;
    masterVolumeSlider.value = masterVolume;
    apiKeyInput.value = userProfile.apiKey || '';

    toggleAudioCheckbox.onchange = toggleAudioActive;
    masterVolumeSlider.oninput = (e) =&gt; {
        masterVolume = parseFloat(e.target.value);
        Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
        saveToLocalStorage('masterVolume', masterVolume);
    };

    saveApiKeyBtn.onclick = () =&gt; {
        userProfile.apiKey = apiKeyInput.value.trim();
        saveToLocalStorage('userProfile', userProfile);
        showMessage("CLÉ API SAUVEGARDÉE !", 'success');
    };

    exportDataBtn.onclick = () =&gt; {
        const dataToExport = {
            userProfile: userProfile,
            weeklyMealPlan: weeklyMealPlan,
            workoutLogs: workoutLogs,
            weightHistory: weightHistory,
            intervalSequences: intervalSequences,
            shifts: shifts,
            savedWorkoutProgram: workoutProgram,
            masterVolume: masterVolume,
            // Nouvelles données du calendrier
            sportProgramCalendar: sportProgramCalendar,
            totalProgramWeeks: totalProgramWeeks,
            currentProgramPhase: currentProgramPhase
        };
        const dataStr = JSON.stringify(dataToExport, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'fitquest_data.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showMessage("DONNÉES EXPORTÉES !", 'success');
    };

    importDataBtn.onclick = () =&gt; { importFileInput.click(); };
    importFileInput.onchange = (event) =&gt; {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = async (e) =&gt; {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (await showConfirmModal("CONFIRMER L'IMPORTATION ? CELA REMPLACERA TOUTES VOS DONNÉES ACTUELLES.")) {
                       // Update global state variables directly
                    userProfile = importedData.userProfile || userProfile;
                    weeklyMealPlan = importedData.weeklyMealPlan || weeklyMealPlan;
                    workoutLogs = importedData.workoutLogs || workoutLogs;
                    weightHistory = importedData.weightHistory || weightHistory;
                    intervalSequences = importedData.intervalSequences || intervalSequences;
                    shifts = importedData.shifts || shifts;
                    workoutProgram = importedData.savedWorkoutProgram || workoutProgram;
                    masterVolume = importedData.masterVolume !== undefined ? importedData.masterVolume : masterVolume;
                    // Nouvelles données du calendrier à importer
                    sportProgramCalendar = importedData.sportProgramCalendar || sportProgramCalendar;
                    totalProgramWeeks = importedData.totalProgramWeeks !== undefined ? importedData.totalProgramWeeks : totalProgramWeeks;
                    currentProgramPhase = importedData.currentProgramPhase || currentProgramPhase;

                        // Save updated state to localStorage
                        saveToLocalStorage('userProfile', userProfile);
                        saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                        saveToLocalStorage('workoutLogs', workoutLogs);
                        saveToLocalStorage('weightHistory', weightHistory);
                        saveToLocalStorage('intervalSequences', intervalSequences);
                        saveToLocalStorage('shifts', shifts);
                        saveToLocalStorage('savedWorkoutProgram', workoutProgram);
                        saveToLocalStorage('masterVolume', masterVolume);

                        showMessage("DONNÉES IMPORTÉES AVEC SUCCÈS ! RECHARGEMENT DE L'APPLICATION.", 'success');
                        setTimeout(() =&gt; { location.reload(); }, 2000);
                    }
                } catch (error) {
                    console.error("Erreur lors de l'importation des données:", error);
                    showMessage("ERREUR: FICHIER D'IMPORTATION INVALIDE OU CORROMPU.", 'error');
                }
            };
            reader.readAsText(file);
        }
    };

    resetAllDataBtn.onclick = async () =&gt; {
        if (await showConfirmModal("ATTENTION: CELA SUPPRIMERA TOUTES VOS DONNÉES ! ÊTES-VOUS SÛR ?")) {
            if (await showConfirmModal("CONFIRMATION FINALE: TOUTES LES DONNÉES SERONT EFFACÉES DÉFINITIVEMENT. CELA EST IRRÉVERSIBLE. CONTINUER ?")) {
                localStorage.clear();
                showMessage("TOUTES LES DONNÉES ONT ÉTÉ EFFACÉES. RECHARGEMENT DE L'APPLICATION.", 'success');
                setTimeout(() =&gt; { location.reload(); }, 2000);
            }
        }
    };
}

// Écouteurs d'événements pour la navigationavigation

function attachEventListeners() {

    // Bouton retour à l'accueil

    document.getElementById('home-button').onclick = () =&gt; renderPage('daily_plan');



    // Écouteurs pour les boutons de navigation (Planning, Sport, Recettes, etc.)

    document.querySelectorAll('.nav-item').forEach(button =&gt; {

        button.onclick = (event) =&gt; {

            const page = event.currentTarget.dataset.page;

            renderPage(page);

        };

    });



    // Écouteur pour le bouton de sauvegarde du profil

    document.getElementById('save-profile-btn').onclick = handleSaveProfile;

}



// Chargement initial de l'application
window.onload = initializeApp;

  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre><div id="preact-border-shadow-host" popover="manual" style="border: none; padding: 0px; margin: 0px; inset: 0px; position: fixed; width: 100vw; height: 100vh; background: transparent; pointer-events: none;"></div></body></html>